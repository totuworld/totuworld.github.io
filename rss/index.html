<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>totuworld&#39;s tech blog</title>
    <description>Full 🥩🔥 Developer</description>
    <link />https://blog.totu.dev/&lt;/link&gt;
    <atom:link href="https://blog.totu.dev/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 20 Mar 2020 10:56:30 +0900</pubDate>
    <lastBuildDate>Fri, 20 Mar 2020 10:56:30 +0900</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      
        <item>
            <title>yalive 구현소개</title>
            <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#들어가는-말&quot; id=&quot;markdown-toc-들어가는-말&quot;&gt;들어가는 말&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#라이브-퀴즈쇼의-핵심-기능&quot; id=&quot;markdown-toc-라이브-퀴즈쇼의-핵심-기능&quot;&gt;라이브 퀴즈쇼의 핵심 기능&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#다른-대안은-없었나&quot; id=&quot;markdown-toc-다른-대안은-없었나&quot;&gt;다른 대안은 없었나?&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#데이터-동기화-살펴보기&quot; id=&quot;markdown-toc-데이터-동기화-살펴보기&quot;&gt;데이터 동기화 살펴보기&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#동기화-데이터-구조&quot; id=&quot;markdown-toc-동기화-데이터-구조&quot;&gt;동기화 데이터 구조&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#퀴즈-정보-수정&quot; id=&quot;markdown-toc-퀴즈-정보-수정&quot;&gt;퀴즈 정보 수정&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#퀴즈-정보-읽기&quot; id=&quot;markdown-toc-퀴즈-정보-읽기&quot;&gt;퀴즈 정보 읽기&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#클라이언트-제출-데이터-처리&quot; id=&quot;markdown-toc-클라이언트-제출-데이터-처리&quot;&gt;클라이언트 제출 데이터 처리&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#nextjs-v9x--now--️&quot; id=&quot;markdown-toc-nextjs-v9x--now--️&quot;&gt;next.js v9.x + now = ❤️&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;들어가는-말&quot;&gt;들어가는 말&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.totu.dev/2019/12/24/yalive-postmortem/&quot;&gt;yalive 제작 후기&lt;/a&gt;에서 숨가빴던 1달간의 개발 과정을 소개했다면 이번에는 yalive를 살펴보며 동작방식을 설명하기로 한다.&lt;/p&gt;

&lt;h2 id=&quot;라이브-퀴즈쇼의-핵심-기능&quot;&gt;라이브 퀴즈쇼의 핵심 기능&lt;/h2&gt;
&lt;p&gt;라이브 퀴즈쇼는 참여자와 진행자가 모두 같은 문제를 보고 같은 결과를 봐야한다. 대시보드와 관리자 페이지 그리고 많은 클라이언트가 같은 데이터를 비슷한 시점에 수신해야한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/yalive-data-01.jpg&quot; alt=&quot;화면간데이터공유&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림에서 보는 것처럼 상황에 따라 관리자페이지에서 데이터를 수정하면 대시보드와 클라이언트는 이 정보를 반영해서 각자 화면을 제어한다. 데이터 동기화만 해결하면 8할은 개발이 끝난 셈이다.&lt;/p&gt;

&lt;p&gt;그럼 어떻게 데이터를 동기화 할 수 있을까? 내 선택은 Firebase의 Cloud Firestore 였다. Cloud Firestore 공식 문서에 따르면 확장한도가 동시 연결 수 약 1,000,000개, 초당 쓰기 1,000회이다. 기획 자체가 실시간 1만명 연결이 아니라 최대 1,000명이 접속할 수 있는 환경이므로 충분하다. 보너스로 인증(authentication)을 사용할 수 있으니 프론트엔드와 백엔드 개발에서 초기 비용을 낮출 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;다른-대안은-없었나&quot;&gt;다른 대안은 없었나?&lt;/h3&gt;
&lt;p&gt;socket이나 gRPC도 생각해보긴 했다. 그런데 yalive 제작에는 무리라고 봤다. 일단 제작 착수 시점이 배포까지 1달 남은 시점이었다. socket이나 gRPC를 사용하려면 이미 어느정도 제작된 솔루션을 가지고 있어야했다. 개발에 참여하는 멤버 중에 적어도 1명이라도 이 경험을 가지고 있어야 가능하다. 하지만 난 맨손이었다. socket.io로 채팅을 만들었던게 언제인지 기억도 가물가물하다.&lt;/p&gt;

&lt;p&gt;Firebase쪽이 상황이 훨씬 좋았다. 다른 토이 프로젝트용으로 Firebase, React.js, Next.js를 이용해서 인증과 회원가입을 처리해뒀다. 덤으로 yalive 개발에 참여한 멤버가 모두 이 스택에 익숙하므로 초기 비용이 낮아졌다.&lt;/p&gt;

&lt;h2 id=&quot;데이터-동기화-살펴보기&quot;&gt;데이터 동기화 살펴보기&lt;/h2&gt;
&lt;p&gt;이제 데이터 동기화를 구체화시켜보자. 잼 라이브를 떠올려보면 된다.&lt;/p&gt;

&lt;p&gt;퀴즈쇼 시작에 앞서 참가자들이 쇼에 들어온다. 진행자가 애드립을 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.clien.net/web/api/file/F01/7618286/9253b739d10fa.png&quot; alt=&quot;잼누나&quot; width=&quot;30%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;문제를 내고 카운트다운을 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ext.fmkorea.com/files/attach/new/20190415/486616/1531092467/1739955072/1e95a2e7d501cdb415876542dd9e7906.png&quot; alt=&quot;문제출제&quot; width=&quot;30%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;참가자 중 몇 퍼센트가 뭘 선택했는지 보여주고 정답을 공개한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://db.kookje.co.kr/news2000/photo/2018/0807/L20180807.99099003342i1.jpg&quot; alt=&quot;정답공개&quot; width=&quot;30%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;탈락자가 생기고 다시 애드립이 진행된다. 이 과장을 반복하다가 끝난다.&lt;/p&gt;

&lt;p&gt;이 흐름을 바탕으로 몇가지 상태를 정의할 수 있었다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;상태이름&lt;/td&gt;
      &lt;td&gt;설명&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PREPARE&lt;/td&gt;
      &lt;td&gt;준비중. 참가자가 입장할 수 있다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IDLE&lt;/td&gt;
      &lt;td&gt;대기 상태. 진행자의 애드립이 이때 나온다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;QUIZ&lt;/td&gt;
      &lt;td&gt;문제가 공개된다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;COUNTDOWN&lt;/td&gt;
      &lt;td&gt;각 참가자가 답을 제출해야하는 제한시간&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CALCULATE&lt;/td&gt;
      &lt;td&gt;집계. 오답자를 가려서 탈락이 몇 명인지 등을 체크한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SHOW_RESULT&lt;/td&gt;
      &lt;td&gt;문제의 정답을 공개한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FINISH&lt;/td&gt;
      &lt;td&gt;모든 퀴즈가 종료된 상태&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;각 상태는 정해진 흐름에 따라 다른 상태로 변경될 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/yalive-data-03.jpg&quot; alt=&quot;상태 흐름&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;동기화-데이터-구조&quot;&gt;동기화 데이터 구조&lt;/h3&gt;
&lt;p&gt;앞서 설명한 상태 정보외에 무엇이 더 필요할까? 먼저 퀴즈에 관한 정보가 필요하다. 전체 참가자와 생존자 숫자도 필요하다.  실제로 사용한 &lt;code&gt;퀴즈 정보&lt;/code&gt; 인터페이스는 아래 코드와 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;export interface QuizOperation {
  /** 상태 */
  status: EN_QUIZ_STATUS;
  /** 제목? 노출할 글자? */
  title?: string;

  /** 참가 가능한 이메일 주소 */
  possibleEmailAddress?: string;

  /** 퀴즈 id(각 퀴즈를 구분하는 값) */
  quiz_id?: string;
  /** 퀴즈 타입 */
  quiz_type?: EN_QUIZ_TYPE;
  /** 퀴즈 설명 */
  quiz_desc?: string;
  /** 퀴즈 이미지 url */
  quiz_image_url?: string;
  /** 사용자가 선택할 수 있는 객관식 문항 */
  quiz_selector?: SelectorItem[];
  /** 퀴즈의 정답(반드시 SHOW_RESULT 상태에서 넣어줘야한다.) */
  quiz_correct_answer?: number;

  /** 전체 참가자 숫자 */
  total_participants: number;
  /** 생존한 참가자 숫자 */
  alive_participants: number;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;퀴즈 정답(quiz_correct_answer)를 퀴즈 설정 시 넣지 않고, 정답 공개(SHOW_RESULT) 전에 넣도록 했다. 아무래도 개발자 도구를 열어 미리 데이터를 확인하는 사람도 있을 수 있기 때문이었다.&lt;/p&gt;

&lt;h3 id=&quot;퀴즈-정보-수정&quot;&gt;퀴즈 정보 수정&lt;/h3&gt;
&lt;p&gt;데이터 수정은 관리자 페이지에서만 가능하도록 했다. 크게 3가지 기능을 수행한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;상태 변경&lt;/li&gt;
  &lt;li&gt;퀴즈 문제 설정&lt;/li&gt;
  &lt;li&gt;오답자 체크 후 생존 참가자 숫자 변경&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;상태 변경은 현재 상태에 따라 다음 상태로 올 수 있는 버튼을 노출했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/yalive-data-04.png&quot; alt=&quot;IDLE일때버튼&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예외처리를 한 부분은 COUNTDOWN 상태이다. 화면에는 10초 타이머가 진행되지만 관리자 페이지에서는 15초 타이머가 실행된다. 타이머가 종료하면 자동으로 CALCULATE 상태로 변경하고, &lt;code&gt;정답 공개&lt;/code&gt; 버튼과 &lt;code&gt;오답자 계산&lt;/code&gt; 버튼이 차례로 나타난다. 이 두 단계를 마치고 SHOW_RESULT 상태로 변경해야한다. 이 시스템을 잘 이해하지 못하는 사람이 운영했다면 어떤 버튼을 눌러야할지 몰라서 사고 나기 딱 좋은 부분이다. 행사 당일 관리자 페이지 운영을 직접 했기때문에 큰 문제가 없었지만 현재는 아래 처럼 개선했다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* CALCURATE 상태에서 정답 공개와 오답자 계산이 순차적으로 자동 진행
* 각 단계중 실패 시 다시 시도가능하도록 버튼이 모두 노출됨
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 이런 수정은 관라자 페이지에서 api 호출을 통해서 처리한다. Firebase SDK를 활용해서 관리자 페이지에서 직접 수정할 수 있지만 이후에 정합성 처리 등을 넣으려면 이게 유리하다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그래놓고 실제로 정합성 체크하는 로직은 없다😱&lt;br /&gt;
&lt;a href=&quot;https://github.com/ya-live/ya-live/issues/31&quot;&gt;서버 사이드에 JSON Schema 도입 · Issue #31 · ya-live/ya-live · GitHub&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;퀴즈-정보-읽기&quot;&gt;퀴즈 정보 읽기&lt;/h3&gt;
&lt;p&gt;데이터를 클라이언트와 대시보드, 관리자 페이지에서 사용할 때는 Firebase SDK 기능을 지원받으면 된다. Cloud  Firestore의 문서(document) 변경 사항을 수신하는 onSnapShot 메서드를 사용했다. 프론트엔드 라이브러리가 React.js이니 함수형 컴포넌트(Functional Component)에서 편리하게 사용할 수 있게 Custom Hook을 만들었다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ya-live/ya-live/blob/master/components/auth/hooks/firestore_hooks.ts&quot;&gt;ya-live/firestore_hooks.ts at master · ya-live/ya-live · GitHub&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;내가 처리한 부분은 여기까지인데 클라이언트와 대시보드를 만든 @alattalatta, @0901sj님이 react.js의 context api를 활용해서 각 컴포넌트에서 데이터를 활용할 수 있도록 했다. 관리자 페이지는 하위 컴포넌트를 가지지 않지만 클라이언트와 대시보드는 상황에 따라 컴포넌트가 변경되니 매번 데이터를 흘리는게 귀찮았겠다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;yalive만들면서 프론트엔드 코드를 볼 수 있어 좋았다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;클라이언트-제출-데이터-처리&quot;&gt;클라이언트 제출 데이터 처리&lt;/h2&gt;
&lt;p&gt;참가자 정보는 퀴즈 정보 하위에 위치한다. 생존 여부와 제출한 답안을 가지는 형태다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;export interface QuizParticipant {
  /** ISO 8601 */
  join: string;
  /** 생존 여부 */
  alive: boolean;
  currentQuizID?: string;
  /** 선택한 번호 */
  select?: number;
  /** 사용자 고유 id */
  id: string;
  /** 사용자 출력 명 */
  displayName: string;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/images/yalive-data-05.png&quot; alt=&quot;참가자데이터구조&quot; /&gt;&lt;/p&gt;

&lt;p&gt;각 클라이언트에서 api를 통해 답안을 제출하면 개별 참가자 정보(Participant)에 선택한 답안과 퀴즈 고유 id를 기록한다. 제한 시간이 종료되면 관리자 페이지에서 오답자를 체크하여 alive 값을 false로 바꿔서 더이상 쇼에 참여할 수 없도록 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/yalive-data-02.jpg&quot; alt=&quot;답안 제출 과정&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 과정에서 api를 통하면 응답을 수신한 시간을 특정할 수 있고 정합성도 체크할 수 있어서 사후에 문제가 발생했을 때 증거를 남길 수 있다. 무엇보다 Firebase SDK를 사용해서 바로 업데이트 하도록하면 정답이 아니더라도 생존 여부를 조작할 수 있다. 어뷰징 요소는 줄이는게 좋다.&lt;/p&gt;

&lt;p&gt;뭔가 공통점이 보이지 않는가? Firebase SDK를 사용하지만 데이터 읽기에만 사용하고 수정은 모두 api를 통하고 있다. 이는 일전에 진행한 Firebase 스터디에서 들은 내용을 바탕으로 정한 정책이다. Firebase를 사용해서 게임을 운영하는 분들은 사용자 어뷰징을 걱정한다. 그래서 개별 클라이언트는 데이터 수신만하고 데이터 변경만 서버사이드에 요청하는 방식으로 운영하여 DB접근을 차단한다고 들었다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그래놓고 실제로 정합성 체크하는 로직은 없다😱 (2)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;nextjs-v9x--now--️&quot;&gt;next.js v9.x + now = ❤️&lt;/h2&gt;
&lt;p&gt;데이터에 대한 설명은 이정도로하고 next.js와 now에 관해 얘기해보겠다.&lt;/p&gt;

&lt;p&gt;프론트엔드 라이브러리는 react.js를 사용했지만 프레임워크는 next.js를 사용했다. 많은 기능을 지원하지만 서버사이드 렌더링(Server Side Rendering)과 파일 시스템 라우팅(File-System Routing)이 편리해서 손에 익어버렸다. 덤으로 프로젝트에 참여한 멤버들이 모두 현업에서 next.js를 사용한다.&lt;/p&gt;

&lt;p&gt;next.js v9.x 버전에서 반가운 2가지 기능이 있다.
첫째는 파일 시스템 기반의 동적 라우팅(&lt;a href=&quot;https://nextjs.org/blog/next-9#dynamic-route-segments&quot;&gt;File system-Based Dynamic Routing&lt;/a&gt;) 이다. &lt;a href=&quot;https://ko.nuxtjs.org/guide/routing/&quot;&gt;nuxt.js&lt;/a&gt;에서 가장 부러운 기능이 동적 라우팅이었는데 이제 된다. 파일 이름에 대괄호([ , ])를 추가하면 url path를 해석해서 해당 정보를 query로 전달해준다.&lt;/p&gt;

&lt;p&gt;둘째는 API 라우트(&lt;a href=&quot;https://nextjs.org/docs#api-routes&quot;&gt;API Routes&lt;/a&gt;)다. 기존에 next.js를 사용해도 서버 사이드에서 처리하는 api는 직접 express.js 등을 활용해서 제작했다. 이제는 &lt;code&gt;/pages/api&lt;/code&gt; 폴더 아래에 파일을 생성해서 백엔드 api를 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;now는 next.js를 만든 zeit사가 운영 중인 서버리스(serverless) 플랫폼이다. 여기에 next.js를 사용하면 아주 기간막히게 잘 달라붙는다. 예를들어 next.js의 API 라우팅을 사용하면 각 파일을 별도의 서버리스 서버로 동작하게 한다 - 내부에서는 aws의 lamba로 1:1 매핑하는 듯하다). aws에서 beanstalk 하나 등록하는 수고를 생각하면 배포 설정도 정말 간단하다.&lt;/p&gt;
</description>
            <pubDate>Fri, 27 Dec 2019 09:00:00 +0900</pubDate>
            <link />https://blog.totu.dev/2019/12/27/yalive-tech-in-side/&lt;/link&gt;
            <guid isPermaLink="true">https://blog.totu.dev/2019/12/27/yalive-tech-in-side/</guid>
            
            
            <category>etc</category>
            
        </item>
      
    
      
        <item>
            <title>yalive 제작 후기</title>
            <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#들어가는-말&quot; id=&quot;markdown-toc-들어가는-말&quot;&gt;들어가는 말&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#d-28-11월-22일---입사-1개월차의-패기&quot; id=&quot;markdown-toc-d-28-11월-22일---입사-1개월차의-패기&quot;&gt;D-28, 11월 22일 - 입사 1개월차의 패기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#첫-삽-11월-26일11월-28일&quot; id=&quot;markdown-toc-첫-삽-11월-26일11월-28일&quot;&gt;첫 삽, 11월 26일~11월 28일&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#d-18-12월-2일-첫번째-개발-미팅&quot; id=&quot;markdown-toc-d-18-12월-2일-첫번째-개발-미팅&quot;&gt;D-18, 12월 2일 첫번째 개발 미팅&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#d-11-12월-9일-두번째-개발-미팅&quot; id=&quot;markdown-toc-d-11-12월-9일-두번째-개발-미팅&quot;&gt;D-11, 12월 9일 두번째 개발 미팅&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#d-8-12월-12일-문제-전달&quot; id=&quot;markdown-toc-d-8-12월-12일-문제-전달&quot;&gt;D-8, 12월 12일 문제 전달&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#d-4-12월-16일-최종-개발-미팅&quot; id=&quot;markdown-toc-d-4-12월-16일-최종-개발-미팅&quot;&gt;D-4, 12월 16일 최종 개발 미팅&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#d-3-12월-17일-최종-문제-전달&quot; id=&quot;markdown-toc-d-3-12월-17일-최종-문제-전달&quot;&gt;D-3, 12월 17일 최종 문제 전달&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#d-2-채팅창&quot; id=&quot;markdown-toc-d-2-채팅창&quot;&gt;D-2, 채팅창&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#d-1-12월-19일-리허설&quot; id=&quot;markdown-toc-d-1-12월-19일-리허설&quot;&gt;D-1, 12월 19일 리허설&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#d-day-12월-20일-행사-당일-1300-경&quot; id=&quot;markdown-toc-d-day-12월-20일-행사-당일-1300-경&quot;&gt;D-DAY, 12월 20일 행사 당일 13:00 경&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#행사-12월-20일-15001600&quot; id=&quot;markdown-toc-행사-12월-20일-15001600&quot;&gt;행사!!! 12월 20일 15:00~16:00&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#회고와-감사-인사&quot; id=&quot;markdown-toc-회고와-감사-인사&quot;&gt;회고와 감사 인사&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;들어가는-말&quot;&gt;들어가는 말&lt;/h2&gt;

&lt;p&gt;2019년 12월 20일, 야놀자는 &lt;code&gt;Merry Circusmas&lt;/code&gt;라는 연말행사를 진행했다. 케이터링 + 각종 게임 + 경품추첨이 있는 행복한 사내 행사다. 행사의  프로그램 중에 하나로 &lt;code&gt;yalive&lt;/code&gt;가 있었다. 영상없이 진행되는 소규모 라이브 퀴즈쇼다(잼라이브를 생각하면 된다). 이런걸 할 수 있냐고 2019년 11월 22일 물어봤다?! 어떤 일이 있었는지 시간 순서로 설명해보겠다.&lt;/p&gt;

&lt;h2 id=&quot;d-28-11월-22일---입사-1개월차의-패기&quot;&gt;D-28, 11월 22일 - 입사 1개월차의 패기&lt;/h2&gt;

&lt;p&gt;야놀자의 사내 행사를 주관하는 Culture&amp;amp;Grow팀이 있다. 해당 팀에 11월 1일 장민서님이 입사한다. 엄청난 핵인싸인지 퇴사하신 분을 통해서 소개 연락이 왔다. 안면트고 얼마 지나서 2회 &lt;code&gt;Tech야,놀자&lt;/code&gt; 스태프로 참여하시더니 문제의 그 날 - 11월 22일 - 메시지로 서바이벌 퀴즈쇼 할 수 있냐고 묻는다.&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/Mh3XF1YLxo8&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;주변 개발자에게 영상에 나오는 앱을 12월 20일까지 만들 수 있느냐고 물어보니 “족히 한 달은 걸리지 않을까?” 하며 모두가 고개를 절레절레 흔들었다고 한다. 신기한 사람이다. 모두가 고개를 흔들었는데 어째서 내게 다시 묻는거지.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/yalive-01.png&quot; alt=&quot;채팅01&quot; width=&quot;40%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아무튼 당시를 떠올려보면 안된다고 타이핑하면서 속으로는 가능해보였다. 잼라이브 형태를 만들어보려고 이전에 생각했었다. Firebase Realtime DB나 Cloud Store를 사용해서 서로 데이터 싱크하고 웹 클라이언트에서 답을 제출한다. 각 클라이언트 간 시간차가 조금 있어도 현장에서 운영으로 풀면되니까 괜찮다. 상금 1억짜리 행사가 아닐테니까 참석자들도 그정도는 감수하겠지. 웹 클라이언트 프로그래밍할 멤버 2명 섭외해달라고 부탁하고 대화를 마쳤다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;태평한 내 성격이 한 몫했군.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;첫-삽-11월-26일11월-28일&quot;&gt;첫 삽, 11월 26일~11월 28일&lt;/h2&gt;
&lt;p&gt;마침 Firebase를 사용하는 토이 프로젝트가 있어서 스케폴딩을 그대로 사용할 수 있었다. 첫번째 개발 미팅 전까지 어느정도 가능성을 확인하고 싶었다. 퇴근하고 짬짬히 만들었는데 따져보니 10시간 정도 들었다. 클라이언트 화면과 퀴즈 제어가 생각한대로 돌아가는걸 확인했다. 이때는 관리툴이 없어서 DB를 직접 조작해가면서 확인했다.&lt;/p&gt;

&lt;h2 id=&quot;d-18-12월-2일-첫번째-개발-미팅&quot;&gt;D-18, 12월 2일 첫번째 개발 미팅&lt;/h2&gt;
&lt;p&gt;혼자 삽질한 결과를 가지고 12월 2일 첫번째 개발 미팅을 가졌다. 프로젝트에 참여하는 멤버들과 공식적인 첫 만남인데 어딘가 익숙했다. 참여한 멤버들은 같은 CX개발실에서 일하는 웹파트 @alattalatta, @0901sj과 API파트 @parksy8189. 이분들 워크로그의 컨트리뷰터이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;역시 토이도 해본 사람이 한다고.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이미 참여한 사람들이 잘 쓰는 기술 스택을 그대로 사용하기로 했다. 짧은 시간에 뭔가 만들려면 도전을 줄이고 기능에만 집중해야한다고 생각했다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프론트엔드 및 API : React.js + Next.js&lt;/li&gt;
  &lt;li&gt;데이터베이스: Firebase&lt;/li&gt;
  &lt;li&gt;배포: now&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이와 별개로 첫번째 미팅 때 개발 규모를 보고 드랍될 수 있다고 생각했다. 이 시기는 2019년 마지막 앱 배포를 앞둔 때라 기획된 기능이 많아 여유가 없었다. 그런데 왠걸 누가 무엇을 할지 정하면서 헤어졌다. 각자 맡은 기능을 어느정도 구현해서 차주에 맞춰보기로 했다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;화면에 송출되는 대시보드 개발 - @alattalatta&lt;/li&gt;
  &lt;li&gt;사용자용 클라이언트 개발 - @0901sj&lt;/li&gt;
  &lt;li&gt;각종 api 지원 - @parksy8189&lt;/li&gt;
  &lt;li&gt;퀴즈 상태 전환 및 정산 등의 기능을 가진 관리자 페이지 개발 - @totuworld&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;개발이 잘되면 사용하고 망하면 안쓰면되고, 플랜B가 있어야한다고 말했다. 물론 귓등으로도 안들었다…&lt;/p&gt;

&lt;h2 id=&quot;d-11-12월-9일-두번째-개발-미팅&quot;&gt;D-11, 12월 9일 두번째 개발 미팅&lt;/h2&gt;

&lt;p&gt;1주일 금방간다. 각자 맡은 기능을 어느정도 구현해서 왔다. 가장 많이 진척된 부분은 대시보드와 관리자 페이지였고 클라이언트 페이지는 손이 더 가야하는 상황이었다. 그리고 만나면서 얘기를 나누면서 필요한 기능이 늘었다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이전 라운드 탈락자 부활 기능&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;얘기치못한 버그들이 발견되서 각 기능별로 수정에 들어갔다지만 그다지 큰 걸림돌을 없어보였다. 두려움만 이기면 됐다. 총괄대표님 보고에 해당 행사 내용이 올라가서 배수진을 치고 개발해야했다. 노 플랜B, 노 빠꾸 개발이라니.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;돌이켜보면 총괄대표님은 이 행사가 망하던 흥하던 상관없었을텐데. 우리가 우리 일을 너무 중요하게 생각했다. 바보같은 노동자들.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;d-8-12월-12일-문제-전달&quot;&gt;D-8, 12월 12일 문제 전달&lt;/h2&gt;
&lt;p&gt;문제는 얼마 안되겠지 생각했는데. 왠걸 60문항이 넘었다. 데이터베이스에 일일히 등록할라고 봤더니 너무 손이 많이간다. 문서도 구글 스프레드시트일줄 알았는데 구글 문서로 줬다. 어쩌지. 잘 살펴보니 어느정도 규칙이 있었다. 원본 문서를 txt로 변경한 뒤 json으로 변환했다. 그리고 Firebase에 문제를 등록하는 스크립트를 만들어서 입력해버렸다.&lt;/p&gt;

&lt;h2 id=&quot;d-4-12월-16일-최종-개발-미팅&quot;&gt;D-4, 12월 16일 최종 개발 미팅&lt;/h2&gt;

&lt;p&gt;진행자까지 총 6명이 모여 최종 점검하는 자리를 가졌다. 개발팀은 12일 따로만서 정답처리, 오답처리, 생존자 숫자 체크, 부활 등의 기능을 미리 점검하고 문제가 된 부분을 수정했다. 문제없이 잘 작동해야했는데 아직 버그가 있었다. 수정! 수정! 수정! 조금 쫄려서 리허설하는 자리를 마련하기로 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/yalive_fix03.jpg&quot; alt=&quot;최종개발미팅&quot; width=&quot;40%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;d-3-12월-17일-최종-문제-전달&quot;&gt;D-3, 12월 17일 최종 문제 전달&lt;/h2&gt;
&lt;p&gt;지난번 문제 전달이후에 문제 순서를 바꿔서 다시 전달받았다. 스크립트 없었으면 정말 눈물 흘릴뻔 했다. 앞과 같은 순서로 변환을 거쳐서 문제를 입력했다.&lt;/p&gt;

&lt;h2 id=&quot;d-2-채팅창&quot;&gt;D-2, 채팅창&lt;/h2&gt;

&lt;p&gt;행사 2일 전에 기능을 추가하다니!! 아무튼 @alattalatta 님이 대시보드에 상황별 사운드 처리 기능을 파워 추가했다. 민서님은 😈인가.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://pbs.twimg.com/media/D4GS_DpWAAAwUZZ?format=jpg&amp;amp;name=900x900&quot; alt=&quot;f**king devs&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://twitter.com/equinusocio/status/1117335800344186881&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;d-1-12월-19일-리허설&quot;&gt;D-1, 12월 19일 리허설&lt;/h2&gt;

&lt;p&gt;마지막이라고 생각하고 기능 테스트를 진행했다. 참가자 처리 부분이 문제가 있어서 수정해야했다. 그리고 민서님이 카운트다운할 때 재생되는 소리가 없다며 기능을 한번 더 추가한다😱. 기능도 하나 더 추가한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;전체 탈락자 부활 기능&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이날 RND 그룹이 50명이 참가하는 골든벨 행사를 했는데 의외로 초반에 많은 사람이 탈락했다. api 개발하는 @parksy8189 님이 전체부활이 필요해보인다고 얘기했다. 후후. 그럼 제가 만들께요~.&lt;/p&gt;

&lt;h2 id=&quot;d-day-12월-20일-행사-당일-1300-경&quot;&gt;D-DAY, 12월 20일 행사 당일 13:00 경&lt;/h2&gt;

&lt;p&gt;행사를 얼마 앞두고 서로 기능을 체크하고 있는데 클라이언트와 대시보드가 서로 상태를 다르게 해석하는 부분을 확인했다. 어떻게 고칠지 고민했는데 @parksy8189 님의 아이디어로 돌파구를 찾았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/yalive_fix01.jpg&quot; alt=&quot;최종파이널수정&quot; width=&quot;40%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다 고치고나서 최종 테스트까지 마친다. 마지막까지 수정하느라 @0901sj 님이 고생했다.&lt;/p&gt;

&lt;h2 id=&quot;행사-12월-20일-15001600&quot;&gt;행사!!! 12월 20일 15:00~16:00&lt;/h2&gt;

&lt;p&gt;몇명이나 참석하지 몰랐는데 왠걸 329명이 참석하는 행사가 됐다. 행사 현장이 좁아서 모두가 오프라인으로 참여하진 못했지만 온라인만 행사에 참여하는 분들도 많았나보다.&lt;/p&gt;

&lt;p&gt;앞에 5문제는 몸풀기 문제였다. 어려운 문제가 하나 있어서 전체 참가자 중 반이 탈락하게 되었다. 진행자가 몸풀기 문제임을 알리고 전체 부활을 선언한다. 다행히 문제 없이 모두 부활되었다. 5문제가 잘 진행되었고, 부활 기능도 멀쩡하니 앞으로는 진행만 잘하면 된다. 여기까지 진행되었을 때 성공을 확신했다. 긴장이 풀렸다.&lt;/p&gt;

&lt;p&gt;중간에 진행용 노트북 배터리가 모두 소진되서 화면이 꺼졌다. 부랴부랴 Culture&amp;amp;Grow팀에서 충전기를 가져와 해결했다. 최후의 4인과 최후의 1인까지 남을 때까지 행사는 무난히 진행해서 완료했다. 🎉🎉🎉 👏👏👏&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/yalive-03.png&quot; alt=&quot;행사완료&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;회고와-감사-인사&quot;&gt;회고와 감사 인사&lt;/h2&gt;
&lt;p&gt;yalive 프로젝트를 하면서 2가지가 좋았다. 전에 뇌내망상으로만 존재하던 라이브 퀴즈쇼를 만들게 되었고 행사를 참여한 사우님들이 많이 좋아해줬다. 현장에서도 정말 반응이 좋았는데 설문조사에서도 가장 좋은 행사로 뽑혔다. 내가 작성한 코드만 보면 말도 안되는 수준이지만 누군가 좋아해준다니 정말 뿌듯하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/yalive-02.png&quot; alt=&quot;최고세션&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음에 비슷한 프로젝트를 하게된다면 의사결정 과정에서 내 목소리를 더 줄여야겠다. 같이 프로젝트에 참여한 멤버들이 원하는 바를 반영하고, 기술 도전이 가능하도록 했다면 어땠을까.&lt;/p&gt;

&lt;p&gt;그리고 이 프로젝트를 진행할 때 기꺼이 참여해준 @alattalatta, @0901sj, @parksy8189 3분 너무 고맙다. 아내에게 말하니 늙은 아저씨랑 놀아주는 &lt;code&gt;고마운 젊은이&lt;/code&gt; 라고 했다. 앞으로도 잘 부탁해요.&lt;/p&gt;

&lt;p&gt;회고에는 나쁜? 사람 - 😈 - 으로 나오지만 민서님 정말 고생많았어요.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;부족한 기능을 몇가지를 추가해서 다른 행사에서도 사용할 수 있게 고쳐볼까 생각중이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ya-live/ya-live&quot;&gt;ya-live 레포지토리&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
            <pubDate>Tue, 24 Dec 2019 09:00:00 +0900</pubDate>
            <link />https://blog.totu.dev/2019/12/24/yalive-postmortem/&lt;/link&gt;
            <guid isPermaLink="true">https://blog.totu.dev/2019/12/24/yalive-postmortem/</guid>
            
            
            <category>etc</category>
            
        </item>
      
    
      
        <item>
            <title>구글, 애플 인앱 영수증 결제 검증 웹 서비스 리뉴얼</title>
            <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#들어가는-말&quot; id=&quot;markdown-toc-들어가는-말&quot;&gt;들어가는 말&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#주요-기능&quot; id=&quot;markdown-toc-주요-기능&quot;&gt;주요 기능&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#변경점&quot; id=&quot;markdown-toc-변경점&quot;&gt;변경점&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#레포지토리&quot; id=&quot;markdown-toc-레포지토리&quot;&gt;레포지토리&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#맺는말&quot; id=&quot;markdown-toc-맺는말&quot;&gt;맺는말&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;들어가는-말&quot;&gt;들어가는 말&lt;/h2&gt;
&lt;p&gt;&lt;del&gt;싸질러놓은&lt;/del&gt; 작성한 글 중에서 가장 자연유입이 많은 것은 &lt;a href=&quot;/2016/02/10/google-oauth/&quot;&gt;구글 인앱 결제 검증 웹 서비스 만들기&lt;/a&gt;와 &lt;a href=&quot;/2016/03/23/ios-validation/&quot;&gt;애플 인앱결제 검증 웹 서비스 제작&lt;/a&gt; 이다.&lt;/p&gt;

&lt;p&gt;그런데 이 글을 2016년에 작성되었고 그 코드는 3년이 넘게 그대로 방치 중이다. 그대로 사용하면 보안 위험이 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;리뉴얼할 수 있게 요청해준 순순스튜디오 고마워요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;node.js와 express.js는 그대로 유지하면서 변경해보았다.&lt;/p&gt;

&lt;h2 id=&quot;주요-기능&quot;&gt;주요 기능&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Google Play Store 인앱결제(in app billing) 검증
    &lt;ul&gt;
      &lt;li&gt;JWT 토큰 생성 방식&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Apple App Store 인앱결제(in app purchase) 검증&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;게임에서 결제가 이뤄진 뒤 영수증을 각 url로 제출하면 정상 결제인지 확인한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;단, 데이터베이스에 영수증을 기록하는 기능은 없기때문에 정상 결제 1건을 가지고 복수번 결제 검증을 요청하는 중복 결제(duplicate payment)는 방어하지 못함.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;변경점&quot;&gt;변경점&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;node.js v10.16 사용&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;TypeScript&lt;/code&gt; 사용&lt;/li&gt;
  &lt;li&gt;비동기 요청은 callback 에서 &lt;code&gt;async/await&lt;/code&gt; 로 변경&lt;/li&gt;
  &lt;li&gt;JSON Schema 를 통해서 request를 검증&lt;/li&gt;
  &lt;li&gt;요청 url 변경
    &lt;ul&gt;
      &lt;li&gt;/validation/iap/google&lt;/li&gt;
      &lt;li&gt;/validation/iap/apple&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;aws beanstalk 배포를 위한 packing 스크립트 추가&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;dev&lt;/code&gt; 모드로 실행 시 아래 명령으로 실행
    &lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm run dev
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;레포지토리&quot;&gt;레포지토리&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/totuworld/InAppPurchaseValidationWebService&quot;&gt;인앱 영수증 결제 검증 웹 서비스&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;살펴보시거나 사용하시다가 질문이 있으시면 해당 레포지토리의 이슈로 등록하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;맺는말&quot;&gt;맺는말&lt;/h2&gt;
&lt;p&gt;이런 서비스가 필요없는 신뢰 사회가 되길 바란다.&lt;/p&gt;
</description>
            <pubDate>Mon, 16 Sep 2019 09:01:00 +0900</pubDate>
            <link />https://blog.totu.dev/2019/09/16/renew-receipt-validation/&lt;/link&gt;
            <guid isPermaLink="true">https://blog.totu.dev/2019/09/16/renew-receipt-validation/</guid>
            
            
            <category>etc</category>
            
            <category>validation</category>
            
            <category>Billing</category>
            
            <category>iab</category>
            
            <category>iap</category>
            
            <category>nodejs</category>
            
            <category>TypeScript</category>
            
        </item>
      
    
      
        <item>
            <title>Tech야,놀자 준비 후기</title>
            <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#들어가는-말&quot; id=&quot;markdown-toc-들어가는-말&quot;&gt;들어가는 말&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#준비-과정&quot; id=&quot;markdown-toc-준비-과정&quot;&gt;준비 과정&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#주제-정하기&quot; id=&quot;markdown-toc-주제-정하기&quot;&gt;주제 정하기&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#장소-예산&quot; id=&quot;markdown-toc-장소-예산&quot;&gt;장소, 예산&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#디자인-의뢰&quot; id=&quot;markdown-toc-디자인-의뢰&quot;&gt;디자인 의뢰&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#행사-안내문-작성하기&quot; id=&quot;markdown-toc-행사-안내문-작성하기&quot;&gt;행사 안내문 작성하기&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#sns-홍보-및-참가자-모객&quot; id=&quot;markdown-toc-sns-홍보-및-참가자-모객&quot;&gt;SNS 홍보 및 참가자 모객&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#발표-사항-체크&quot; id=&quot;markdown-toc-발표-사항-체크&quot;&gt;발표 사항 체크&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#예비-발표-준비&quot; id=&quot;markdown-toc-예비-발표-준비&quot;&gt;예비 발표 준비&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#행사장-준비&quot; id=&quot;markdown-toc-행사장-준비&quot;&gt;행사장 준비&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#좌석-배치&quot; id=&quot;markdown-toc-좌석-배치&quot;&gt;좌석 배치&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#리셉션-스크린-음향&quot; id=&quot;markdown-toc-리셉션-스크린-음향&quot;&gt;리셉션, 스크린, 음향&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#음악과-기본-pt&quot; id=&quot;markdown-toc-음악과-기본-pt&quot;&gt;음악과 기본 PT&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#기타-편의-제공&quot; id=&quot;markdown-toc-기타-편의-제공&quot;&gt;기타 편의 제공&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#행사-진행&quot; id=&quot;markdown-toc-행사-진행&quot;&gt;행사 진행&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#진행자와-관찰자&quot; id=&quot;markdown-toc-진행자와-관찰자&quot;&gt;진행자와 관찰자&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#사진-촬영-및-동영상-촬영&quot; id=&quot;markdown-toc-사진-촬영-및-동영상-촬영&quot;&gt;사진 촬영 및 동영상 촬영&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#행사-후&quot; id=&quot;markdown-toc-행사-후&quot;&gt;행사 후&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#만족도-설문&quot; id=&quot;markdown-toc-만족도-설문&quot;&gt;만족도 설문&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#자료-수집과-정리&quot; id=&quot;markdown-toc-자료-수집과-정리&quot;&gt;자료 수집과 정리&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#회고-자리&quot; id=&quot;markdown-toc-회고-자리&quot;&gt;회고 자리&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#맺는말&quot; id=&quot;markdown-toc-맺는말&quot;&gt;맺는말&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#감사-인사&quot; id=&quot;markdown-toc-감사-인사&quot;&gt;감사 인사&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;들어가는-말&quot;&gt;들어가는 말&lt;/h2&gt;

&lt;p&gt;한마디로 요약하자면 &lt;code&gt;행사 준비&lt;/code&gt;는 아무나 하는 게 아니었다. 첫 행사라서 그런지 세상 걱정이 모두 몰려들어 속이 다 울렁거렸다. 정신 건강만 생각하면 정말 함부로 시작하면 안 되는 거였다.&lt;/p&gt;

&lt;p&gt;첫 행사 기획 및 운영으로 많은 사람들을 힘들게 했지만 2회 차부터 이런 실수를 줄이고자 준비 후기를 남겨본다.&lt;/p&gt;

&lt;h2 id=&quot;준비-과정&quot;&gt;준비 과정&lt;/h2&gt;
&lt;p&gt;행사 뽐뿌가 가득 찼지만 무엇부터 해야 할지 몰랐다. 결론만 놓고만 실행 단계에서 무엇을 할지 몰라요보다 기획 단계에서 &lt;code&gt;주제&lt;/code&gt;가 무엇인지 모르는 게 더 문제였다.&lt;/p&gt;

&lt;h3 id=&quot;주제-정하기&quot;&gt;주제 정하기&lt;/h3&gt;
&lt;p&gt;처음 &lt;code&gt;Tech야,놀자&lt;/code&gt;를 기획했을 때는 나 스스로 주제가 명확하지 않았다. 밋업? 테크 톡? 갈피를 잡지 못했고 경험담을 들려줄지 기술 관련한 내용만 발표할지 구체적이지 않았다. 그러다 보니 발표자의 주제 선정도 헷갈리는 부분이 있고, 참가자의 기대 수준도 크게 달랐다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://wanual.gitbook.io/wanual/a-to-z/undefined-4/undefined&quot;&gt;[행사기획] 행사기획의 기본&lt;/a&gt; 에도 잘 설명돼있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;기획 의도가 명확하지 않아 강사, 참여자 모두 혼란스러웠던 행사로 끝이 났고, 글쓴이는 울며 그 날을 회고했다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;Tech야,놀자&lt;/code&gt;는 초기에 테크 톡이었다. 기술적인 내용을 담은 발표를 남기고 싶었다. 그런데 준비 과정에서 야놀자가 어떻게 일하는 지도 들려주고 싶어 졌다. 그러다 보니 밋업처럼 변질돼서 이도저도 아닌 게 되었다. 그럼에도 초기에 잡은 &lt;code&gt;Server-side Node.js with TypeScript&lt;/code&gt; 란 주제가 공표 되었다. 참가자 만족도 설문에서도 여실히 나타났다. 누군가는 일하는 방식을 들으러 왔고 누군가는 기술 발표를 기대하고 참가했더라.&lt;/p&gt;

&lt;p&gt;정말 짧게 요약할 수 있는 주제를 먼저 선정하자. 그러면 레퍼런스 찾기도 좋다.&lt;/p&gt;

&lt;h3 id=&quot;장소-예산&quot;&gt;장소, 예산&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Tech야,놀자&lt;/code&gt;의 경우 30~40명 규모의 작은 행사로 기획했다. &lt;del&gt;솔직히 30명도 못 채울까 봐 두려웠다.&lt;/del&gt; 인원 규모가 정해지자 장소 섭외는 일사천리로 진행되었다. 사내에 휴게 공간인 &lt;code&gt;For. REST&lt;/code&gt;를 사용할 수 있었기 때문이다. 그런데 이 장소에는 문제가 있다. 야놀자 본사 건물 1층을 통과해서 7층 &lt;code&gt;For. REST&lt;/code&gt;로 진입해 야하는데, 1층에서 방문자 확인이 돼야만 게이트를 통과할 수 있다. 원칙대로는 신원 확인 후 모두 방문증을 만들어야 했는데 19시 이후 행사라서 참석자 명단만 제출하면 안전팀이 통과시켜줬다. 다음에는 기회가 된다면 참가자 명찰을 만들어서 1층에서 배부하고 건물 안전팀이 이를 확인하고 게이트를 통과하면 조금 더 수월할 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;For. REST&lt;/code&gt;는 사용 신청을 통해서 특정 날짜의 특정 시간을 사용할 수 있다. 그러니 행사를 기획한다면 미리미리 잡아두면 된다.&lt;/p&gt;

&lt;p&gt;예산은 많을수록 좋으나 유료 행사가 아니기 때문에 어디선가 받아와야만 한다. 이때 무엇에 사용할지 잘 정해야 한다. 초기에 &lt;code&gt;간식&lt;/code&gt; 정도만 제공할 생각이라서 굉장히 짜게 예산을 불렀는데 후에 행사를 준비할 때 보니 이 외에도 돈 들어갈 일이 많아서 굉장히 후회했다.&lt;/p&gt;

&lt;p&gt;아래는 제공한 것과 제공하지 못한 것을 업다운으로 표시해보겠다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;👍간식 및 다과 비용&lt;/li&gt;
  &lt;li&gt;👍스태프 명찰(개인비용)&lt;/li&gt;
  &lt;li&gt;👎X배너, 포스터 등 출력물&lt;/li&gt;
  &lt;li&gt;👎스태프 티셔츠&lt;/li&gt;
  &lt;li&gt;👎참가자 선물(급하게 피플파트너실 도움으로 지급)&lt;/li&gt;
  &lt;li&gt;👎발표자 선물&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;발표자 선물을 주지 못하더라도 참가자와 스태프 관련한 것은 뭐라도 더 챙겨야 했는데 생각도 못했다. 그리고 스태프 명찰은 CXPO실 유미리 님의 도움이 아니었으면 만들지도 못했다.&lt;/p&gt;

&lt;h3 id=&quot;디자인-의뢰&quot;&gt;디자인 의뢰&lt;/h3&gt;
&lt;p&gt;디자인 의뢰도 꼼꼼히 생각해야만 가능한 부분이었다. 페이스북으로 홍보하고 기술 블로그에 글만 적어서 내보낼 생각이었어서 의뢰를 몇 개 하지 못했는데 실상 들어가는 디자인이 많았다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SNS 홍보용 이미지
    &lt;ul&gt;
      &lt;li&gt;페이스북, 트위터 등 원하는 규격이 다르고 노출하는 형식도 정해야 한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사이니지용 이미지
    &lt;ul&gt;
      &lt;li&gt;사내에 비치된 사이니지를 통해 노출할 수 있기 때문에 포스터 비용을 아낄 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기술 블로그 대표 이미지&lt;/li&gt;
  &lt;li&gt;안내 발송용 이메일 이미지
    &lt;ul&gt;
      &lt;li&gt;템플릿 작업을 했으면 참 좋았을 텐데 아쉽다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;참가 및 만족도 설문용 이미지
    &lt;ul&gt;
      &lt;li&gt;설문지 상단에 들어가는데 아무것도 없으면 낚시성 폼으로 보여서 오해하기 좋다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;발표자용 PT 커버 이미지&lt;/li&gt;
  &lt;li&gt;스태프 명찰 이미지&lt;/li&gt;
  &lt;li&gt;참가자 명찰 이미지&lt;/li&gt;
  &lt;li&gt;행사장 안내 인쇄물 이미지&lt;/li&gt;
  &lt;li&gt;행사장 안내 PT 이미지&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 중 실제로 의뢰하고 받은 것은 SNS 홍보용 이미지와 사이니지용 이미지였다. 만약 더 구체적인 그림을 알고 있었다면 일관되게 노출할 수 있었을 것 같은데 아쉽다.&lt;/p&gt;

&lt;p&gt;디자인 의뢰는 피플파트너실(HR)을 통해 제공받는데 이때도 어느 정도 양식이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;주제&lt;/li&gt;
  &lt;li&gt;장소, 일시, 참석 대상자&lt;/li&gt;
  &lt;li&gt;이미지에 넣고자 하는 주요 사항들&lt;/li&gt;
  &lt;li&gt;디자인 컨셉&lt;/li&gt;
  &lt;li&gt;레퍼런스 이미지&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그리고 디자인 의뢰는 최소 2주 정도로 여유로운 게 좋다. 그래야 디자인 수신 후 수정 요청도 가능하고 디자이너도 편하게 작업할 수 있다. 많은 산출물을 얻고 싶다면 충분한 시간이 필요하다.&lt;/p&gt;

&lt;h3 id=&quot;행사-안내문-작성하기&quot;&gt;행사 안내문 작성하기&lt;/h3&gt;
&lt;p&gt;행사 안내는 모객 시점부터 필요하기 때문에 모객을 앞두고 반드시 작성해야 한다. 이때 이 안내문만 읽고 참석이 가능하게 유도하는 게 좋다. 이 부분을 놓쳐서 초기에 배포된 안내문이 매우 부실했다. 그렇다 보니 혼선이 발생했다. 그리고 참석자 선정 방식 등은 서술하지 않는 게 좋다. 이후 운영하면서 변경되는 부분까지 모두 대외적인 설명이 필요하다.&lt;/p&gt;

&lt;p&gt;다음 사항은 꼭 추가해야 하는 부분이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;소개글&lt;/li&gt;
  &lt;li&gt;일시 및 장소&lt;/li&gt;
  &lt;li&gt;신청방법&lt;/li&gt;
  &lt;li&gt;발표 내용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://yanolja.github.io/2019/07/tech_yanolja&quot;&gt;Tech야,놀자 안내문&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;특히나 발표가 있다면 이 부분이 핵심 컨텐츠이므로 모객에 큰 도움이 된다. 적어도 1개의 발표라도 간단한 소개 글을 받아서 넣어두도록 하자. 그리고 다른 행사의 안내문을 많이 봐두면 좋다. 준비 과정에서 급하게 찾느라고 여기저기서 본걸 짜깁기했더니 아주 누더기가 나왔다. ex 야놀자 멤버인 강미경(우아한 형제들)님의 도움이 아니었다면 안내문은 정말 폭망 수준이었다.&lt;/p&gt;

&lt;p&gt;기타 안내 부분도 별거 아니라고 생각하지 말고 꼼꼼히 적어야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;현장 등록 가능 여부&lt;/li&gt;
  &lt;li&gt;참가자 안내 방법&lt;/li&gt;
  &lt;li&gt;행사 당일 건물 내 이동 방법&lt;/li&gt;
  &lt;li&gt;간식이 식사를 대체할 수 있는지 혹은 외부 음식을 가지고 올 수 있는지 여부&lt;/li&gt;
  &lt;li&gt;주차 지원 여부&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이외에도 필요하다고 생각되면 주저 말고 추가하자. 처음에는 주차 안내 하나 넣었는데 미경 님 조언으로 많이 챙길 수 있었다. 넣고 보니 다른 행사에도 이것저것 많이 쓰여있는 게 보인다.&lt;/p&gt;

&lt;h3 id=&quot;sns-홍보-및-참가자-모객&quot;&gt;SNS 홍보 및 참가자 모객&lt;/h3&gt;
&lt;p&gt;야놀자에서 개발자 관련한 홍보 채널은 Facebook의 &lt;a href=&quot;https://www.facebook.com/devyanolja/&quot;&gt;&lt;code&gt;개발자야,놀자&lt;/code&gt;&lt;/a&gt;가 전부다. 채널이 하나이니 공식적인 홍보는 이곳을 통해서 진행했다. 다만 글쓰기 권한을 가진 분을 찾느라고 고생했는데 다행히 마케팅팀 도움으로 권한을 얻었다. 현재는 다른 분께도 권한이 있어서 나보다 쉽게 공지 등을 올릴 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;SNS 홍보글에는 짧게 요약되는 글로 홍보하고 자세한 사항을 상세 안내문에 넣어서 링크했더니 편리했다. 매번 홍보글 수정할 필요 없이 안내문만 수정하면 되기 때문이다.&lt;/p&gt;

&lt;p&gt;그리고 참가자 모객은 구글 폼으로 받았다. 이때 들은 지적사항 중 하나가 구글 폼에도 적당한 안내 사항과 상세 안내문 링크가 있었으면 좋겠다는 것이었다. 다음에 행사를 진행하게 되면 반드시 폼에도 &lt;code&gt;안내문 링크&lt;/code&gt;를 넣고 전달해야겠다.&lt;/p&gt;

&lt;p&gt;무료 행사기 때문에 No Show가 얼마나 될지 몰랐다. 하여 목표 인원만큼만 사람을 받으려고 했는데 큰 오산이었다. ex 야놀자 멤버인 노현석(네이버) 님을 통해서 무료 행사 일 때 평균 얼마나 No Show가 얼마나 되는지 들었다. 무료 행사의 경우 &lt;code&gt;30~40%&lt;/code&gt; No Show가 있을 수 있고 비나 눈이 오면 더 높아질 수 있다고 들었다. 다행히 200% 이상 참가자 신청이 있어서 정원 대비 30% 인원을 더 참가자로 선정할 수 있었다. 당일 참석자를 카운트해보니 놀랍게도 30% No Show였다.&lt;/p&gt;

&lt;p&gt;한 가지 아쉬웠던 점은 직원분들이 직접 참가 신청을 하거나 지인을 초대하고 싶어했다. 최초에 기획단계에서 이를 고려해서 &lt;code&gt;일반 참가자&lt;/code&gt;와 &lt;code&gt;초대 참가자&lt;/code&gt;를 나눠 받아야겠다.&lt;/p&gt;

&lt;h3 id=&quot;발표-사항-체크&quot;&gt;발표 사항 체크&lt;/h3&gt;
&lt;p&gt;이번 행사를 준비할 때 가장 못한 부분이 이것이었다. 발표자 중 일찍 준비한 분이 있는가 하면 업무에 밀려서 늦게 준비한 분도 있었다. 이 부분을 미리 체크해서 데드라인을 만들었다면 발표 컨텐츠가 더 풍부했을 것 같다.&lt;/p&gt;

&lt;p&gt;3자를 통해 어떤 부분을 추가해야 할지 알아가는 &lt;code&gt;발표 리뷰&lt;/code&gt;를 마련해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;예비-발표-준비&quot;&gt;예비 발표 준비&lt;/h3&gt;
&lt;p&gt;진행에 따라 갑자기 시간이 늘어지거나 짧아지는 변수가 있다. &lt;code&gt;Tech야,놀자&lt;/code&gt;는 앞의 2 세션이 빨리 끝나서 시간이 많이 생겼다. 이때 예비 발표가 있었다면 정말 매끄럽게 진행될 수 있었겠다.&lt;/p&gt;

&lt;p&gt;당시 현장에서 갑작스럽게 채용 관련 QnA를 진행했어서 세션을 맡아주신 분이 많이 당황했다. 듣는 분들도 만족스럽지 못했다 꼭 하나쯤 미리 준비해두자.&lt;/p&gt;

&lt;h2 id=&quot;행사장-준비&quot;&gt;행사장 준비&lt;/h2&gt;
&lt;p&gt;행사 당일에는 어떤 준비를 해야 할까? 사실 리셉션에 컴퓨터 올려두고 간식만 준비하면 될 줄 알았다. 실제로 할 일은 더 많았다.&lt;/p&gt;

&lt;h3 id=&quot;좌석-배치&quot;&gt;좌석 배치&lt;/h3&gt;
&lt;p&gt;야놀자의 &lt;code&gt;For REST&lt;/code&gt;는 평소에 휴게 공간처럼 사용된다. 하여 좌석배치가 발표하기에 적합하지 않았다. 추가 의자가 꽤 많이 준비되어있으니 미리 올라가서 자리를 깔아야 한다. 그리고 행사 성격에 따라 테이블이나 소파를 활용하면 좋겠다. 소파를 좌석으로 사용했더니 굉장히 편안해 보여서 좋았다.&lt;/p&gt;

&lt;p&gt;준비가 어느 정도 되었을 때 빈자리를 찍어서 홍보 채널로 올려두자.&lt;/p&gt;

&lt;h3 id=&quot;리셉션-스크린-음향&quot;&gt;리셉션, 스크린, 음향&lt;/h3&gt;
&lt;p&gt;리셉션에 홍보물이나 간식 등을 비치한다. 입구에서 바로 보이는 자리라서 큰 혼란 없이 등록이 이뤄졌다. 동선을 안내하는 포스터나 PT가 없어서 아쉬웠다.&lt;/p&gt;

&lt;p&gt;마이크와 음향 상태, 스크린은 발표자와 함께 미리미리 확인했으면 더 좋았겠다. 당일날 확인했더니 스크린에 글자가 얼마나 크게 나오는지 확인했을 때 전체 슬라이드를 수정하기에는 시간이 너무 빠듯했다. 그래서 가독성이 떨어지게 작은 폰트가 사용되기도 했고, 스크린 출력 시 대비가 약하여 읽을 수 없는 글자도 있었다. 되도록 80pt이상 큰 글자 사용을 권한다.&lt;/p&gt;

&lt;h3 id=&quot;음악과-기본-pt&quot;&gt;음악과 기본 PT&lt;/h3&gt;
&lt;p&gt;행사장에 진입했을 때 아무런 소리가 나지 않으면 분위기가 너무 빡빡했다. 다행히 스태프 중에 블루투스 스피커가 있어서 하우스 음향 외로 음악을 틀 수 있었다. 미리 플레이 리스트까지 확보하면 더 좋았겠다.&lt;/p&gt;

&lt;p&gt;행사장 안에서 참가자가 알아야 하는 정보는 기본 PT를 만들어서 반복시키면 된다. 이걸 모르고 있다가 당일 올라가 보니 아무것도 없는 게 너무 휑해서 만들었다. 디자인도 이상하고 오타도 났다. 미리미리 체크해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;기타-편의-제공&quot;&gt;기타 편의 제공&lt;/h3&gt;
&lt;p&gt;쓰레기통이 준비되어있지만 여분의 박스 등을 깔아서 추가로 쓰레기를 버릴 수 있게 유도하는 게 좋았다. 기존에 준비된 쓰레기통으로 40명 인원의 쓰레기를 받기에는 조금 모자 라보였다.&lt;/p&gt;

&lt;p&gt;에어컨이 특정 시간이 되면 꺼지는 것 같았다. 40명이 모이니 금방 더워졌다. 다행히 에어컨 리모컨이 비치되어있다. 에어컨 작동 여부를 확인하고 조치해야 한다. 당일 더운지 몰랐는데 행사에 참석했던 분이 알려줘서 에어컨을 켜게 되었다.&lt;/p&gt;

&lt;h2 id=&quot;행사-진행&quot;&gt;행사 진행&lt;/h2&gt;
&lt;p&gt;행사 진행은 순서 안내만 있으면 충분할 것으로 생각했다. 하지만 앞서 말한 에어컨 미동작 같은 문제가 발생한다.&lt;/p&gt;

&lt;h3 id=&quot;진행자와-관찰자&quot;&gt;진행자와 관찰자&lt;/h3&gt;
&lt;p&gt;행사가 타임 테이블과 같이 진행되지 않더라. 각종 변수가 생긴다. 이때 안정적으로 상황을 정리하고 알려주는 진행자가 필요하다. 다행히 스태프 중 진행을 맡아주시는 분이 있었다. 인원이 부족해도 이 일만 챙기는 분을 꼭 지정해두자.&lt;/p&gt;

&lt;p&gt;그리고 진행자가 보는 시선과 다르게 전체를 바라보는 관찰자가 필요하다. 돌발 상황을 인지하고 지시를 내려야 한다. 발표도 함께 준비하느라 이 부분을 소홀히 했더니 참가자들이 어떤 상태인지 파악이 되지 않았다. 이 부분은 스태프와 미경 님의 도움이 정말 컸다.&lt;/p&gt;

&lt;h3 id=&quot;사진-촬영-및-동영상-촬영&quot;&gt;사진 촬영 및 동영상 촬영&lt;/h3&gt;
&lt;p&gt;사진이나 동영상을 기록해두면 좋다. 사진은 생각지 못하고 있었는데 스태프 유용우 님(CX개발실)이 자발적으로 촬영해줘서 그나마 기록을 가지게 되었다. 되도록 스태프 중 사진 촬영만 담당할 사람을 섭외하면 좋겠다. 반드시 좋은 카메라가 아니어도 된다. 사진이 없는 것보다 휴대전화로 찍은 사진이라도 있는 게 좋다.&lt;/p&gt;

&lt;p&gt;발표를 기록하는 동영상 촬영은 휴대전화로 했다. 나쁘지는 않았는데 휴대전화 배터리 문제가 있었다. 하여 근접에서 촬영한 영상중 하나는 못쓰게 되었다. 그러니 미리미리 보조 배터리를 챙겨둬야 한다. 세션만큼 기록했을 때 저장 공간이 무리 없는지도 미리 촬영해서 체크해볼 필요가 있었다. 다행히 저장 공간은 충분했지만 체크하지 못했다면 영상 전체를 잃을 뻔했다.&lt;/p&gt;

&lt;p&gt;촬영하는 스태프는 전문성이 있으면 좋겠지만 없어도 레코드 시작과 끝만 누를 수 있으면 충분하니 전담할 수 있도록 해주자.&lt;/p&gt;

&lt;h2 id=&quot;행사-후&quot;&gt;행사 후&lt;/h2&gt;
&lt;p&gt;행사가 마무리되면 빠르게 참석자가 엘리베이터를 이용해서 빠져나간다. 이때 혹시 놓고 간 물건은 없는지 빨리 확인해야겠다. 간혹 물건을 두시고 갈 수 있기 때문이다.&lt;/p&gt;

&lt;p&gt;장소 정리하는 일이 필요한데 장소 배치를 크게 바꾸지 않으면 복구도 금방 된다. 또한 일손이 많으면 빠르다. 회사에서 진행할 때는 스태프가 아니라도 동료의 힘을 빌릴 수 있어서 빨리할 수 있었다.&lt;/p&gt;

&lt;h3 id=&quot;만족도-설문&quot;&gt;만족도 설문&lt;/h3&gt;
&lt;p&gt;만족도 설문을 미리 만들어두고 원하는 채널로 작성을 부탁하자. 사실 참석자 설문보다 월등히 적은 수가 수집되지만 의견을 직접 들을 수 있어 도움이 된다. 꼭 미리 준비해서 행사 후 짧은 시간 안에 발송하자. 참석자 시간이 지나면 귀찮아져서 설문을 더 안 할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;자료-수집과-정리&quot;&gt;자료 수집과 정리&lt;/h3&gt;
&lt;p&gt;사진이나 동영상은 되도록 행사 당일이나 다음날 모아서 공유 폴더에 모으면 좋다. 다행히 스태프들이 알아서 공유해줘서 팀 구글 드라이브에 저장할 수 있었다.&lt;/p&gt;

&lt;h3 id=&quot;회고-자리&quot;&gt;회고 자리&lt;/h3&gt;
&lt;p&gt;행사가 끝났으니 스태프와 함께 회고해야 한다. 일이 끝나고 너무 늦게 잡으면 일을 잊을 수 있다고 하니 최소 1주일 안에 진행하자. &lt;code&gt;Tech야,놀자&lt;/code&gt; 회고는 행사 후 2일 뒤에 진행했다.&lt;/p&gt;

&lt;h2 id=&quot;맺는말&quot;&gt;맺는말&lt;/h2&gt;
&lt;p&gt;돌이켜보면 정말 많은 분들의 힘으로 진행한 첫 행사다. 이렇게 많은 일이 일어날지 꿈에도 몰랐다. 참석자가 모두 오기는 할지 불안에 떨었고 행사가 끝나자 피드백을 보면서 피눈물을 흘리기도 했다. 하지만 어쩌랴. 내가 부족한 탓인 것을.&lt;/p&gt;

&lt;p&gt;그래도 동료 덕분에 너무 감동받았다. 너무 피곤했지만 집에 가서 아내에게 감동을 전하느라 일하는 아내를 괴롭혔을 정도다. 이렇게 적극적인 동료들이 주위에 있다는 점이 너무 행복했다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;감사-인사&quot;&gt;감사 인사&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;행사 준비에 컨설팅해주고 당일에도 많은 부분을 챙겨준 ex 야놀자 멤버 강미경 님&lt;/li&gt;
  &lt;li&gt;작두 위에서 내려온 듯한 No Show 조언해 주신 ex 야놀자 멤버 노현석 님&lt;/li&gt;
  &lt;li&gt;행사 준비 시작부터 끝까지 잘 챙겨주신 윤하영 님&lt;/li&gt;
  &lt;li&gt;이름표며 촬영용 삼각대며 말하지 않아도 챙겨준 유미리 님&lt;/li&gt;
  &lt;li&gt;발표 듣고 싶었을 텐데 궂은일 하느라 수고한 이태현 님, 양문규 님, 유용우 님&lt;/li&gt;
  &lt;li&gt;집도 먼데 당일 갑자기 일손을 빌려주신 김연지 님&lt;/li&gt;
  &lt;li&gt;리셉션에서 활약해주신 김수연 님&lt;/li&gt;
  &lt;li&gt;바쁜 일정에도 발표자로 참여해주신 박선영 님, 이병준 님&lt;/li&gt;
  &lt;li&gt;이 행사가 있기까지 물심양면으로 지원해주신 최성일 님&lt;/li&gt;
  &lt;li&gt;행사 준비에 여러모로 도와주신 김우리 님, 김지현 님&lt;/li&gt;
  &lt;li&gt;바쁜 일정에도 디자인해주시느라 고생하신 김하람 님&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 외에도 당일 도와주신 많은 분들 정말 감사합니다. 이렇게 많은 도움을 받을 수 있을지 생각도 못했습니다. 여러분이 있어 정말 행복했습니다. 다음에도 잘 부탁드립니다.&lt;/p&gt;
</description>
            <pubDate>Thu, 25 Jul 2019 09:00:00 +0900</pubDate>
            <link />https://blog.totu.dev/2019/07/25/tech_yanolja_postmortem/&lt;/link&gt;
            <guid isPermaLink="true">https://blog.totu.dev/2019/07/25/tech_yanolja_postmortem/</guid>
            
            
            <category>etc</category>
            
        </item>
      
    
      
        <item>
            <title>30인 규모팀의 커피 주문하기 - 커피투게더</title>
            <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#들어가는-말&quot; id=&quot;markdown-toc-들어가는-말&quot;&gt;들어가는 말&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#커피-주문의-문제&quot; id=&quot;markdown-toc-커피-주문의-문제&quot;&gt;커피 주문의 문제&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#문제-정리&quot; id=&quot;markdown-toc-문제-정리&quot;&gt;문제 정리&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#신기능-제작&quot; id=&quot;markdown-toc-신기능-제작&quot;&gt;신기능 제작!&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#1일-차---api-개발&quot; id=&quot;markdown-toc-1일-차---api-개발&quot;&gt;1일 차 - api 개발&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#2일-차---화면-개발&quot; id=&quot;markdown-toc-2일-차---화면-개발&quot;&gt;2일 차 - 화면 개발&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#운영-기록&quot; id=&quot;markdown-toc-운영-기록&quot;&gt;운영 기록&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#리팩토링&quot; id=&quot;markdown-toc-리팩토링&quot;&gt;리팩토링&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#마무리&quot; id=&quot;markdown-toc-마무리&quot;&gt;마무리&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#참고자료&quot; id=&quot;markdown-toc-참고자료&quot;&gt;참고자료&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;들어가는-말&quot;&gt;들어가는 말&lt;/h2&gt;
&lt;p&gt;조직 생활을 하다보면 커피(차) 한 잔하며 휴식하는 일이 생긴다. 도란 도란 얘기도 나누고 새로온 사람과 인사도 나눌 수 있는 꼭 필요한 시간이다. 하지만 팀 규모가 10인을 넘으면 주문이 일이다. 야놀자의 범 CX실(CXPO, CXDEV)은 2019년 1/4분기에 30명이 넘어갔다. 와아~&lt;/p&gt;

&lt;h2 id=&quot;커피-주문의-문제&quot;&gt;커피 주문의 문제&lt;/h2&gt;
&lt;p&gt;커피 주문은 간단하다. 원하는 주문을 말하고 계산하면 된다.  하지만 사람이 많아지면 주문을 모으는 일이 힘들다. 아래 예시를 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/coffeeorder/coffee_order_01.jpg&quot; alt=&quot;주문예시&quot; width=&quot;40%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CX실의 규칙은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자신이 주문할 메뉴가 있는지 쓰레드를 살핀다.&lt;/li&gt;
  &lt;li&gt;주문이 없다면 신규 메뉴를 쓰레드에 남긴다.&lt;/li&gt;
  &lt;li&gt;혼자만 주문했어도 반드시 ✋ 이모지를 남겨서 카운트하기 쉽도록 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 예시에서 &lt;code&gt;아이스 아메리카노&lt;/code&gt; 를 살펴보자. 샷을 추가하가한 메뉴와 &lt;code&gt;아이스아메&lt;/code&gt; 라고 따로 등록한 것까지 비슷한 주문이 흩어져있다. 또 아이스아메는 ✋이모지가 없다. 신규 입사자가 늘어나면서 규칙 전파가 잘 안된다고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;주문 몇 잔인지 체크하기도 어렵다. 또 실제 주문 중인데 주문이 바뀌는 일도 가능하다. 주문에 성공해도 어떤게 내 주문인지 확인하기 어려웠다.&lt;/p&gt;

&lt;h3 id=&quot;문제-정리&quot;&gt;문제 정리&lt;/h3&gt;

&lt;p&gt;위 문제를 해결하는 방법을 정리해보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;같은 주문을 누적해서 표시&lt;/li&gt;
  &lt;li&gt;총 몇 잔인지 합계 표시&lt;/li&gt;
  &lt;li&gt;특정 시점에서 주문을 종료하여 변경 불가능하도록 설정&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;신기능-제작&quot;&gt;신기능 제작!&lt;/h2&gt;

&lt;p&gt;CX실에는 &lt;a href=&quot;https://yanolja.github.io/2018/09/Work-Log&quot;&gt;워크로그 개발기&lt;/a&gt;가 기 개발된 상태였다. 곧 CX실 인원이 커피 주문을 하는 서비스라면 &lt;code&gt;워크로그&lt;/code&gt;에 새로운 기능을 추가하면 될 터!&lt;/p&gt;

&lt;h3 id=&quot;1일-차---api-개발&quot;&gt;1일 차 - api 개발&lt;/h3&gt;

&lt;p&gt;커피(차) 한 잔 하는 하는 휴식을 &lt;code&gt;이벤트&lt;/code&gt;로 생각했다. 이벤트에 주최자와 참석자를 특정할 수 있다. 그리고 이벤트는 &lt;code&gt;주문&lt;/code&gt;을 가질 수 있다. 주문은 &lt;code&gt;음료&lt;/code&gt; id를 특정하는데 이때 주문자의 - 휘핑 없이같은 - 옵션을 추가할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/coffeeorder/coffee_order_db.png&quot; alt=&quot;주문db&quot; /&gt;&lt;/p&gt;

&lt;p&gt;개략적인 구조는 저렇다. 이를 바탕으로 &lt;code&gt;이벤트&lt;/code&gt;, &lt;code&gt;주문&lt;/code&gt;, &lt;code&gt;참가자&lt;/code&gt;, &lt;code&gt;음료&lt;/code&gt;에 관한 &lt;a href=&quot;https://en.wikipedia.org/wiki/Create,_read,_update_and_delete&quot;&gt;CRUD&lt;/a&gt; api를 제작했다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;GET /events 이벤트 목록&lt;/li&gt;
  &lt;li&gt;POST /events 이벤트 등록&lt;/li&gt;
  &lt;li&gt;GET /events/:event_id 이벤트 정보&lt;/li&gt;
  &lt;li&gt;PUT /events/:event_id 이벤트 수정&lt;/li&gt;
  &lt;li&gt;GET /events/:event_id/guests 참가자 목록&lt;/li&gt;
  &lt;li&gt;POST /events/:event_id/guests 참가자 등록&lt;/li&gt;
  &lt;li&gt;GET /events/:event_id/orders 주문 목록&lt;/li&gt;
  &lt;li&gt;POST /events/:event_id/orders 주문 추가 및 갱신&lt;/li&gt;
  &lt;li&gt;DELETE /events/:event_id/orders/:guest_id 주문 삭제&lt;/li&gt;
  &lt;li&gt;GET /beverages 음료 목록&lt;/li&gt;
  &lt;li&gt;POST /beverages 음료 등록&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;추가로 사내 메신저인 &lt;a href=&quot;https://slack.com/&quot;&gt;슬랙&lt;/a&gt; 데이터를 워크로그 DB에 등록한 상태이므로 &lt;code&gt;참가자&lt;/code&gt; 에게 메시지 발송하는 기능도 추가했다.&lt;/p&gt;

&lt;h3 id=&quot;2일-차---화면-개발&quot;&gt;2일 차 - 화면 개발&lt;/h3&gt;
&lt;p&gt;개발한 화면은 총 3개다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;전체 &lt;code&gt;이벤트&lt;/code&gt; 목록 출력 페이지&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;이벤트&lt;/code&gt; 등록 페이지&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;이벤트&lt;/code&gt; 상세 페이지&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;재사용가능한 컴포넌트가 별로 없어서 새로 만들었지만 구현이 간단한 편이라서 생각보다 빨리 완료했다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;워크로그는 razzle + after.js + react.js + mobx 기반&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/coffeeorder/quickquick.png&quot; alt=&quot;뚝딱맨&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;운영-기록&quot;&gt;운영 기록&lt;/h2&gt;

&lt;p&gt;2일 간의 가열찬 개발 후 대망의 서비스 오픈!!&lt;/p&gt;

&lt;figure class=&quot;large&quot;&gt;
  &lt;div class=&quot;myvideo&quot;&gt;
     &lt;video style=&quot;width:50%&quot; controls=&quot;&quot; loop=&quot;loop&quot;&gt;
         &lt;source src=&quot;/images/coffeeorder/i_love_coffee.mp4&quot; type=&quot;video/mp4&quot; /&gt;
     &lt;/video&gt;
  &lt;/div&gt;
&lt;figcaption&gt;커피 주문 동작예시&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;CX실 채널에서 크게 환영받았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/coffeeorder/coffee_order_launch.png&quot; alt=&quot;서비스오픈&quot; /&gt;&lt;/p&gt;

&lt;p&gt;손쉽게 끝날줄 알았지만 데이터베이스(Database)가 터진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/coffeeorder/coffee_order_error.jpg&quot; alt=&quot;서비스에러&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;돈으로 막을 수 있는건 돈으로 막는게 최고! Firebase를 유료 모델로 올려서 첫날 서비스를 마쳤다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;최소 기능만 가지고 서비스를 강행 오픈했을 때 참사를 경험&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;리팩토링&quot;&gt;리팩토링&lt;/h3&gt;

&lt;p&gt;가만 보니 사용자 전체 목록 조회 부분과 이벤트 내 주문, 음료 목록 전체 로딩을 매번 새롭게 하고 있었다. 변경(Create, Update, Delete)발생할 때만 새롭게 데이터를 읽어서 서버 인메모리에 저장한다. 평소의 읽기는 인메모리 캐시를 먼저 확인하고 비었으면 데이터베이스로부터 데이터를 읽도록 했다.&lt;/p&gt;

&lt;h2 id=&quot;마무리&quot;&gt;마무리&lt;/h2&gt;

&lt;p&gt;이 후 자잘한 업데이트 중이다. 죽었던 다른 기능을 살리고, 불편 사항을 접수해서 개선하기도 한다. &lt;code&gt;토이 프로젝트&lt;/code&gt;는 재미있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/totuworld/time-recorder-viewer&quot;&gt;워크로그 레포지토리&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
            <pubDate>Wed, 17 Apr 2019 09:00:00 +0900</pubDate>
            <link />https://blog.totu.dev/2019/04/17/coffeetogether/&lt;/link&gt;
            <guid isPermaLink="true">https://blog.totu.dev/2019/04/17/coffeetogether/</guid>
            
            
            <category>etc</category>
            
        </item>
      
    
      
        <item>
            <title>아빠 왜 집에서 일해요? (feat. aws)</title>
            <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#들어가는-말&quot; id=&quot;markdown-toc-들어가는-말&quot;&gt;들어가는 말&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#어플리케이션의-미동작-확인&quot; id=&quot;markdown-toc-어플리케이션의-미동작-확인&quot;&gt;어플리케이션의 미동작 확인&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#어디가-문제야&quot; id=&quot;markdown-toc-어디가-문제야&quot;&gt;어디가 문제야?&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#복구-작업&quot; id=&quot;markdown-toc-복구-작업&quot;&gt;복구 작업&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#그렇다면-내가-직접-설치해주지&quot; id=&quot;markdown-toc-그렇다면-내가-직접-설치해주지&quot;&gt;그렇다면 내가 직접 설치해주지!&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#마무리&quot; id=&quot;markdown-toc-마무리&quot;&gt;마무리&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;들어가는-말&quot;&gt;들어가는 말&lt;/h2&gt;

&lt;p&gt;AWS의 PaaS(Platform as a Service)인 Elastic Beanstalk(이하 Beanstalk)로 node.js 어플리케이션을 배포/운영하고 있다. 로컬이나 dev 환경에서 작동을 확인한 배포판이 production 환경으로 배포만 하면 npm install 시 문제를 발생시킨다?!. 이때 어떻게 대처했는지 기록을 남긴다.&lt;/p&gt;

&lt;h2 id=&quot;어플리케이션의-미동작-확인&quot;&gt;어플리케이션의 미동작 확인&lt;/h2&gt;
&lt;p&gt;크론잡(cronjob)처럼 일정 주기로 정해진 일을 처리하는 어플리케이션이 있다. 해당 어플리케이션은 각각의 테스크를 수행하고 슬랙의 특정 채널에 결과를 남긴다. 그런데 production 환경의 메시지가 사라졌다.&lt;/p&gt;

&lt;h3 id=&quot;어디가-문제야&quot;&gt;어디가 문제야?&lt;/h3&gt;
&lt;p&gt;Beanstalk 환경에 접속해서 node.js 로그를 확인해봤다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;## nodejs 로그를 확인
$ tail /var/log/nodejs/nodejs.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;production 배포판이 특정 패키지를 찾을 수 없어서 시작단계에서 실패하고 있었다. 최근 로그 100줄을 다운받아 확인해보니 npm install 시 특정 패키지를 설치하는데 실패한 기록이 있었다. 개발 환경을 배포한 배포판과 같은 commit으로 돌리고 패키지 설치를 진행해보니 실제로 패키지가 없었다. 어떤 과정에서 누가 패키지를 삭제했는지 모르겠지만 일단 production 환경을 살리자!&lt;/p&gt;

&lt;h2 id=&quot;복구-작업&quot;&gt;복구 작업&lt;/h2&gt;
&lt;p&gt;우선 문제가 된 패키지의 상위 버전이 있는지 확인해서 설치했다. 그리고 npm audit 에서 문제로 지적된 몇몇 패지키지도 업데이트했다. 그리고 배포판을 만들어서 dev 환경으로 뿌렸더니 잘 된다. 그런데 production으로 배포해보니 실패를 거듭했다. 역시 패키지 설치단계에서 에러를 반환하고 특정 패키지가 없다는 에러를 내고 있었다.&lt;/p&gt;

&lt;h3 id=&quot;그렇다면-내가-직접-설치해주지&quot;&gt;그렇다면 내가 직접 설치해주지!&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;eb cli&lt;/code&gt;로 Beanstalk 환경에 접속한 뒤 아래처럼 실행했다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;## sudo 권한 획득
$ sudo su

## 설치된 nodejs 버전 보기. 10.13 버전이 있는지 확인하는 용도
$ ls /opt/elasticbeanstalk/node-install

## path 설정
$ export PATH=$PATH:/opt/elasticbeanstalk/node-install/node-v10.13.0-linux-x64/bin/

## 소스코드 있는 곳
$ cd /var/app/current

## package 설치!
$ npm install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;직접 패키지를 설치했더니 문제없이 잘 설치되었다. 이제 남은건 node 프로세스를 재시작하는 것!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;## node 프로세스 kill (sudo 권한 필요)
$ pkill -f node

## 프로세스 list 확인
$ initctl list

## nodejs 서비스 시작
$ initctl start nodejs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 Beanstalk의 health check을 지켜보거나 node.js 로그를 확인해보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;## nodejs 로그를 확인
$ tail /var/log/nodejs/nodejs.log
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;마무리&quot;&gt;마무리&lt;/h2&gt;
&lt;p&gt;출근해서 왜 문제가 되었나 살펴봤더니 dev와 production 환경의 node.js 플랫폼 버전이 달랐다. 버전을 맞추니 모든 문제가 사라졌다. 역시 기본이 제일 중요하다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;아빠가 집에와서 일하느라 놀아주지 못해서 미안해~ 😭&lt;/p&gt;
&lt;/blockquote&gt;
</description>
            <pubDate>Wed, 09 Jan 2019 09:00:00 +0900</pubDate>
            <link />https://blog.totu.dev/2019/01/09/aws-beanstalk/&lt;/link&gt;
            <guid isPermaLink="true">https://blog.totu.dev/2019/01/09/aws-beanstalk/</guid>
            
            
            <category>aws</category>
            
        </item>
      
    
      
        <item>
            <title>워크로그 개발기</title>
            <description>&lt;blockquote&gt;
  &lt;p&gt;이 글은 2018년 9월 10일에 [야놀자 기술 블로그][https://yanolja.github.io/2018/09/Work-Log]에 게시된 글을 백업한 것 입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;저는 야놀자 CX 서비스실의 API 파트에서 백엔드(90%)와 웹 프론트엔드(10%) 프로그래머로 일하는 송요창입니다.&lt;/p&gt;

&lt;p&gt;개정된 근로기준법에 따라 2018년 7월 1일부터 300인 이상 규모 기업인 경우 &lt;a href=&quot;http://www.etoday.co.kr/news/section/newsview.php?idxno=1627574&quot;&gt;주 40시간(최대 52시간) 근로&lt;/a&gt;합니다. 이에 따라 야놀자에서도 업무 집중도 향상과 함께 업무 시간을 명시하는 방안이 논의되었습니다. 이런 배경 속에서 만들어진 &lt;code&gt;워크로그&lt;/code&gt; 개발 경험을 이야기하겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;개인의-업무-시간-작성&quot;&gt;개인의 업무 시간 작성&lt;/h2&gt;

&lt;p&gt;근로 시간이 기존 대비 단축되면서 각 개인의 업무 시간을 기록하고 기준 근로 시간을 초과하였을 때 이를 소진하도록 하는 방향이 결정되었지만 어떤 도구를 사용할지가 문제였습니다. Timing, TMetric, 출퇴근 기록기 알밤 등 다양한 도구를 사용해서 각자 기록을 시작했습니다.&lt;/p&gt;

&lt;h3 id=&quot;1차-시도---workflow--alfred-활용&quot;&gt;1차 시도 - Workflow + Alfred 활용&lt;/h3&gt;

&lt;p&gt;그러던 중에 캘린더를 이용해서 출/퇴근 기록을 남기고 슬랙(Slack)으로 메시지를 발송하는 방법을 CX 서비스실 강미경 님이 공유합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/worklog/2018-07-101-6ba58f46-0c56-457e-a06e-ad3a19be9799.16.25.png&quot; alt=&quot;미경님은 개발자같은 기획자&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;캘린더와 - 유료인 경우 - 슬랙 모두에 기록이 남는 장점이 있습니다. 사용하기 쉽습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;iOS 앱인 &lt;a href=&quot;https://workflow.is&quot;&gt;Workflow&lt;/a&gt;를 이용해서 캘린더에 이벤트를 등록하고 슬랙으로 메시지를 전송.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;데스크톱이나 노트북은 &lt;a href=&quot;https://www.alfredapp.com&quot;&gt;Alfred&lt;/a&gt;의 Workflows 기능으로 해결할 수 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/worklog/2018-09-10_23-10-04-045c607b-88b8-47d1-8c6f-fca7c6575757.png&quot; alt=&quot;Alfred 워크플로우 공유&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;workflow--alfred로-워크로그를-기록하는-단점&quot;&gt;Workflow + Alfred로 워크로그를 기록하는 단점&lt;/h4&gt;

&lt;p&gt;개인적으로 편리했지만 CX 서비스실 내부로 전파하여 사용하기에는 문제가 있었습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;안드로이드 휴대전화를 사용하는 경우 Workflow를 사용할 수 없습니다.&lt;/li&gt;
  &lt;li&gt;아이폰을 쓰더라도 유료로 판매되는 Workflow를 사지 않으면 쓸 수 없습니다.&lt;/li&gt;
  &lt;li&gt;Alfred를 쓰더라도 Power Pack을 구매한 사용자만 Workflows를 적용할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/worklog/2018-09-11_06-09-52.png&quot; alt=&quot;돈이 필요한 Alred&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2차-시도---슬랙봇-활용&quot;&gt;2차 시도 - 슬랙봇 활용&lt;/h3&gt;

&lt;p&gt;위에서 언급된 문제를 해결하고 구성원 누구나 추가 앱 설치 없이 손쉽게 접근할 수 있는 슬랙봇에 주목합니다. 캘린더가 아니라 데이터베이스를 활용해서 개발하면 어떨지 논의했습니다.&lt;/p&gt;

&lt;p&gt;늦은 저녁(대략 23시부터 03시)에 Firebase 실시간 데이터베이스(Realtime Database)와 Firebase 클라우드 함수(Functions)를 활용해서 단순한 슬랙봇을 만들었습니다.&lt;/p&gt;

&lt;p&gt;슬랙을 실행한 뒤 슬래시 커맨드(slash command)로 &lt;code&gt;/wl 출근&lt;/code&gt;을 입력하면 출근 로그가 추가되고 완료 메시지를 수신합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/worklog/2018-09-10_23-15-05-14e54bb1-a41d-455d-9b26-971e96a7cf2d.png&quot; alt=&quot;뿌듯해하며 사용법 공유&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;슬랙의-3초-이내-응답-요구&quot;&gt;슬랙의 3초 이내 응답 요구&lt;/h4&gt;

&lt;p&gt;단순한 기능이었지만 슬랙봇을 활용해서 워크로그를 작성하는 동료가 조금 늘었을 때 치명적인 문제가 발생했습니다.&lt;/p&gt;

&lt;p&gt;슬랙의 슬래시 커맨드는 3초 이내로 응답할 때 완료 메시지를 노출합니다. 3초를 초과하면 아래 메시지를 노출합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/worklog/2018-09-10_23-17-45-a6b76514-2425-4a40-852a-21c58ff86762.png&quot; alt=&quot;버그리포트&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Firebase 클라우드 함수로 작성한 코드에 문제가 있었습니다. 단순한 로그 데이터와 사용자 요청에 대한 기록을 모두 완수한 후에 응답을 보내도록 했습니다. 이 부분에서 응답 지연이 발생합니다.&lt;/p&gt;

&lt;p&gt;기록은 된다고 변명해봤지만, 사용자가 기록 여부를 알 수 없으니 재시도하는 횟수가 늘어났습니다. 중복된 데이터를 삭제 요청하는 사용자가 늘었습니다. 이런 불편을 겪고 초기 사용자가 이탈했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/worklog/2018-09-11_06-24-30.png&quot; alt=&quot;이탈하는 사용자&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 문제를 제외하고도 다수 사용자의 특정 기간 내 로그를 모두 살펴보기에 슬랙봇은 그다지 좋은 도구가 아니었습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;제가 잘 못 쓴 것이지 슬랙봇에게는 죄가 없습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;3차-시도---웹페이지-도입&quot;&gt;3차 시도 - 웹페이지 도입&lt;/h3&gt;

&lt;p&gt;앞서 말한 문제가 대두하기 전 다수의 로그를 살펴보기 위해 웹페이지를 제작 중에 있었습니다. 프로그래밍에는 &lt;a href=&quot;https://yanolja.github.io/2018/01/Nextjs-webview&quot;&gt;야놀자 앱 하이브리드&lt;/a&gt;에서 다뤄본 React.js 외에 최근 소개받은 razzle, After.js를 사용했습니다(이에 관한 회고는 아래서 짧게 다룹니다).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Firebase 실시간데이터 베이스에 쌓인 로그를 Firebase 클라우드 함수로 제작된 API로 사용자별, 일자별로 불러서 표시하는 정도로 개발 착수.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;웹페이지로 조회 기능을 만든 시점과 맞물려 슬랙봇이 무용지물이 되었습니다. 로그인 기능을 제작하고 웹페이지에서 워크로그를 추가할 수 있도록 했습니다. 기록과 조회가 웹페이지로 대체 된 것입니다🎉🎉.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Firebase 인증은 정말 편리합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/worklog/2018-09-11_06-40-45.png&quot; alt=&quot;슬랙봇 안녕&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;대형-이벤트&quot;&gt;대형 이벤트&lt;/h2&gt;

&lt;p&gt;이렇게 만들었지만 떠나버린 사용자를 돌아오게 만드는 일은 불가능했습니다. 저를 제외하고 몇몇 분들만 사용하는 소소한 서비스로 사라질 예정이었습니다. 그런데 CX 서비스실 실장이신 하희진 님이 전격적으로 CX 서비스실 전 구성원이 워크로그를 통해 기록을 남겨달라고 요청하셨습니다. DAU가 10배는 급상승했습니다(1~2명에서 20명 이상으로). 많은 트래픽📈이 들어오니 부족한 기능과 어설픈 기록 시스템 등이 문제가 되기 시작합니다.&lt;/p&gt;

&lt;p&gt;엎친 데 덮친 격으로 &lt;code&gt;초과 근무 차감&lt;/code&gt;이란 주 기능 오픈에 대한 관리자(희진 님)와 사용자의 요구가 커졌습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;할 일이 넘쳐난다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;dau-20의-공포&quot;&gt;DAU 20의 공포&lt;/h3&gt;

&lt;p&gt;요구사항을 분석하고 구현하면서 미비한 규칙을 관리자와 자주 논의했습니다. 논의 결과에 따라 메뉴가 생겼다가 사라졌다가를 반복해서 사용자의 혼란이 가중되었습니다. 아직 제작되지 않은 관리자 기능 때문에 데이터베이스를 직접 수정하는 일도 빈번했습니다.&lt;/p&gt;

&lt;p&gt;무엇보다 갑자기 새로운 도구를 사용하는 사용자의 질문이 쏟아졌습니다. 주 40시간을 어떻게 측정할지, 초과근무시간의 근거나 법정 휴식시간 발생 요건 등 대부분은 규칙에 관한 질문이었습니다. 30분 안에 같은 질문을 5번 듣고 동일하게 답변하는 헤프닝도 있었습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;🤔 어디서 많이 본 모습인데? 바로 IT산업 전체에서 자주 일어나는 일입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;점진적-개선&quot;&gt;점진적 개선&lt;/h3&gt;

&lt;p&gt;우선 비슷한 질문을 모아 FAQ 페이지를 개설했습니다(우리 PO가 자주 하는 업무라서 배운 풍월이 도움이 되었습니다). 지나치게 사용자 기능을 제한하여 CS가 늘어난 측면이 있어서 규칙이 확정된 부분만 사용자 기능 제한을 풀었습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;금주 내의 로그는 언제든 추가 및 수정할 수 있도록 변경했습니다.&lt;/li&gt;
  &lt;li&gt;누적된 초과시간은 금주 중 언제라도 사용할 수 있도록 변경했습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;한 주가 끝나면 잘못된 로그가 있는지 검사한 뒤 로그 수정 후 초과시간 확정하는 일은 하고 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;배포되는 버전마다 변경사항을 문서에 남기고 전체 사용자에게 공지했습니다.&lt;/p&gt;

&lt;p&gt;차감 기능은 자투리 시간과 CX 서비스실 구성원의 배려로 개발하였습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;다행히 6월에 태어난 둘째가 새벽 4~5시면 한 번씩 울어서 알람 없이 기상할 수 있었습니다😭.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;개인-회고&quot;&gt;개인 회고&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;워크로그&lt;/code&gt;를 제작하면서 크게 2가지를 느꼈습니다.&lt;/p&gt;

&lt;h3 id=&quot;미비한-요구사항-분석은-개발-비용을-상승시킨다&quot;&gt;미비한 요구사항 분석은 개발 비용을 상승시킨다&lt;/h3&gt;

&lt;p&gt;하나의 요구사항은 여러 기능을 필요로 합니다. 자세한 분석 없이 뇌내 망상으로만 개발에 착수했더니 구조를 변경하느라 시간을 많이 소모했습니다.&lt;/p&gt;

&lt;p&gt;초과 시간을 예로 들면 우선 차감 메뉴를 만들고 있었습니다. 그런데 차감에 근거가 되는 누적 시간이 없습니다. 그럼 누적을 기록할 수 있는 모델을 제작합니다. 1일 8시간 기준으로 기록하도록 개발합니다. 주 40시간이 넘을 때 초과 시간이 발생하는 규칙이라서 1주일 단위로 마감하는 방식으로 변경합니다.&lt;/p&gt;

&lt;p&gt;이렇게 우왕좌왕하며 개발하니 밀고 나가는 힘이 약했습니다. 프로덕트 개발 시 PO가 이 부분을 많이 돌봐줘서 기본 없는 프로그래머가 되었습니다(😭).&lt;/p&gt;

&lt;h3 id=&quot;개발은-50-운영이-나머지-50다&quot;&gt;개발은 50%. 운영이 나머지 50%다&lt;/h3&gt;

&lt;p&gt;마이너 버전이라도 개발을 완료하고 배포할 때마다 한고비 넘었다고 생각했습니다. 그렇지만 진짜 서비스가 단단해지는 것은 사용자를 만날 때부터였습니다.&lt;/p&gt;

&lt;p&gt;사용자는 관리자보다 인내심이 없습니다. 개선 사항을 슬랙을 통해서 말해주고, 잘못된 기록이 있으면 수정을 요구했습니다. 이상한 규칙이 발견될 때마다 피드백이 왔습니다. 정당한 요구와 피드백이지만 1인 개발자가 감당하기는 벅찬 부분이 있었습니다.&lt;/p&gt;

&lt;p&gt;피드백을 정리해서 수정할 부분을 JIRA에 정리하고 작업하기를 반복했습니다. 이 과정을 통해 초기보다 더 다듬을 수 있었습니다.&lt;/p&gt;

&lt;p&gt;저는 근무시간 중에만 CS 대응을 했음에도 피곤했습니다. 이런 일을 매일 매시간 겪고 있는 야놀자 PO와 IT 업계 동료들은 정말 대단한 사람입니다. 이 자리를 빌려 다시 한번 존경합니다.&lt;/p&gt;

&lt;h3 id=&quot;개발-관련-회고신약-임상-결과&quot;&gt;개발 관련 회고(신약💊 임상 결과)&lt;/h3&gt;

&lt;p&gt;토이 프로젝트이기 때문에 회사에서 사용하는 기술 외에 새로운 기술을 다뤄봤습니다. React.js와 함께 엄청나게 사랑받고 있는 vue.js가 아닌 이유는 개발 시간이 촉박해서 공부할 시간이 없었다고 핑계 대봅니다.&lt;/p&gt;

&lt;h4 id=&quot;razzle--afterjs--&quot;&gt;razzle + After.js = 👍&lt;/h4&gt;

&lt;p&gt;React.js를 사용할 때 주로 Next.js를 사용해왔지만 이번에는 razzle과 After.js를 사용했습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/jaredpalmer/razzle&quot;&gt;razzle&lt;/a&gt;은 create-react-app처럼 React.js 애플리케이션을 제작할 수 있도록 초기 구성을 도와줍니다. React.js 외에도 Vue, Angular, Preact, Elm 등을 지원합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/jaredpalmer/after.js&quot;&gt;After.js&lt;/a&gt;는 Next.js처럼 서버사이드 렌더링을 지원합니다. Next.js와 다르게 React Route 4를 이용해서 라우팅을 지원합니다.&lt;/p&gt;

&lt;p&gt;사용해본 소감은 razzle이 아무런 설정도 하지 않도록 도와주고 있어서 편리했습니다. TypeScript 도입도 예시가 있어서 쉽게 적용할 수 있었습니다. 코드 수정 후 웹페이지를 다시 로딩하는 핫 리로드(hot reload)도 잘 작동합니다. After.js는 서버사이드 렌더링 시 getInitialProps 를 사용할 수 있어서 Next.js에 익숙한 저에게 편리했습니다. 무엇보다 Next.js처럼 route를 변경하기 위해서 next-route에 의존하지 않아서 편리했습니다(대신 React Route를 의존합니다).&lt;/p&gt;

&lt;p&gt;저처럼 프로젝트 셋업을 어려워하는 초심자에게 유용합니다(검색할 때 사례를 더 많이 찾으려면 Next.js가 더 유리합니다).&lt;/p&gt;

&lt;p&gt;배포는 초기에 Aws의 beanstalk을 활용하다가 &lt;a href=&quot;https://zeit.co/&quot;&gt;Zeit&lt;/a&gt;가 운영하는 now로 변경했습니다. Node.js나 docker에 익숙하고 커맨드 라인 인터페이스(cli)를 사용하는 데 어려움이 없다면 사용할만 합니다. 리전이 모두 해외라서 응답속도가 빠르진 않습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Zeit는 Next.js 프레임워크를 제작한 회사입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;도움-주신-분&quot;&gt;도움 주신 분&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;🤔 아이디어와 기획에 도움을 주고 사용자가 돼주신 R&amp;amp;D CX 서비스실 강미경 님&lt;/li&gt;
  &lt;li&gt;🐛 제보에 적극적인 R&amp;amp;D CX 서비스실 노현석 님&lt;/li&gt;
  &lt;li&gt;DAU를 비약적으로 높여주신 R&amp;amp;D CX 서비스실 하희진 님&lt;/li&gt;
  &lt;li&gt;미약한 사용성과 구린 UI임에도 잘 사용해주고 계신 R&amp;amp;D CX 서비스실 모든 구성원!!&lt;/li&gt;
  &lt;li&gt;공감의 👀🌽! 눈물 흘리는 역할로 열연해주신 R&amp;amp;D UX/UI팀 김하연 님&lt;/li&gt;
  &lt;li&gt;이 글을 리뷰해주신 유관종 님, 노현석 님, 구본한 님&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;무엇보다 이런 프로젝트가 가능하도록 도와준 R&amp;amp;D CX 서비스실 내 API파트 전원에게 🙇‍ 감사합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;참고한-자료&quot;&gt;참고한 자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/evenbit/building-a-slack-app-with-firebase-as-a-backend-151c1c98641d&quot;&gt;https://medium.com/evenbit/building-a-slack-app-with-firebase-as-a-backend-151c1c98641d&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://api.slack.com/slash-commands&quot;&gt;https://api.slack.com/slash-commands&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://firebase.google.com/docs/database/web/start&quot;&gt;https://firebase.google.com/docs/database/web/start&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
            <pubDate>Mon, 10 Sep 2018 09:00:00 +0900</pubDate>
            <link />https://blog.totu.dev/2018/09/10/work-log/&lt;/link&gt;
            <guid isPermaLink="true">https://blog.totu.dev/2018/09/10/work-log/</guid>
            
            
            <category>typescript</category>
            
            <category>razzle</category>
            
            <category>after.js</category>
            
        </item>
      
    
      
        <item>
            <title>3분 게임 서버(Firebase) 진행사항 1</title>
            <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#들어가는-말&quot; id=&quot;markdown-toc-들어가는-말&quot;&gt;들어가는 말&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2018년은-뭘&quot; id=&quot;markdown-toc-2018년은-뭘&quot;&gt;2018년은 뭘?&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#진행-사항&quot; id=&quot;markdown-toc-진행-사항&quot;&gt;진행 사항&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#다음-주제&quot; id=&quot;markdown-toc-다음-주제&quot;&gt;다음 주제&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#맺음말&quot; id=&quot;markdown-toc-맺음말&quot;&gt;맺음말&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;들어가는-말&quot;&gt;들어가는 말&lt;/h2&gt;

&lt;p&gt;2018년 1/4분기는 어떻게 지났는지 모르겠다. 그냥 정신차리고보니 3월 30일이다.&lt;/p&gt;

&lt;h2 id=&quot;2018년은-뭘&quot;&gt;2018년은 뭘?&lt;/h2&gt;
&lt;p&gt;2017년 3월에 &lt;a href=&quot;https://github.com/totuworld/Wendy&quot;&gt;Wendy 프로젝트&lt;/a&gt; 첫번째 파트를 종료했다. &lt;del&gt;그리고 해당 프로젝트는 장렬하게 산화했다.&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;그후 여러가지 핑계로 2017년은 별 활동없이 지나갔다. 2018년은 무엇을할지 고민하다 순순이의 추천과 때마침 시작된 Firebase 스터디 덕분에 Firebase로 방향을 잡았다.&lt;/p&gt;

&lt;p&gt;Unity 3D로 게임 클라이언트를 제작하는 클라이언트 프로그래머가 간단히 사용할 수 있는 게임 서버 제작을 연재해볼까 한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;일은 내가 안해요. Google이 해요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;진행-사항&quot;&gt;진행 사항&lt;/h3&gt;
&lt;p&gt;Firebase 스터디에서 첫 주제로 인증(Auth)을 다뤄서 아래 2개의 글을 작성했다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.totu.dev/2018/03/22/firebaseandunity-01/&quot;&gt;3분 게임 서버(Firebase) - Auth 익명 로그인&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.totu.dev/2018/03/22/firebaseandunity-02/&quot;&gt;3분 게임 서버(Firebase) - Auth 소셜 로그인&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;다음-주제&quot;&gt;다음 주제&lt;/h3&gt;
&lt;p&gt;다음 주제는 데이터베이스(Realtime Database)이다. Unity로 로또를 할 수 있게 클라이언트를 만들고 데이터 관리를 다루려고 한다. 게임 만드는 과정은 통째로 넘어가버릴 것이고 - 클라이언트 안한지 오래되어 수준이 아주 낮아 - 데이터베이스만 다루려고 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/lotto_proto_01.gif&quot; alt=&quot;프로토타입수준실화냐&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이거 만든다고 5시간 썼다면 믿으시겠습니까!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;맺음말&quot;&gt;맺음말&lt;/h2&gt;
&lt;p&gt;미래의 토투가 해야할 일이 밀린 회사와 6월말 출산을 앞둔 2/4분기. 과연 얼마나 글을 진행할 수 있을까. 미래의 토투 힘내라.&lt;/p&gt;
</description>
            <pubDate>Fri, 30 Mar 2018 09:00:00 +0900</pubDate>
            <link />https://blog.totu.dev/2018/03/30/report/&lt;/link&gt;
            <guid isPermaLink="true">https://blog.totu.dev/2018/03/30/report/</guid>
            
            
            <category>firebase</category>
            
        </item>
      
    
      
        <item>
            <title>3분 게임 서버(Firebase) - Auth 소셜 로그인</title>
            <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#들어가는-말&quot; id=&quot;markdown-toc-들어가는-말&quot;&gt;들어가는 말&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#준비-과정&quot; id=&quot;markdown-toc-준비-과정&quot;&gt;준비 과정&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#facebook-로그인&quot; id=&quot;markdown-toc-facebook-로그인&quot;&gt;Facebook 로그인&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#프로그래밍-준비&quot; id=&quot;markdown-toc-프로그래밍-준비&quot;&gt;프로그래밍 준비&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#facebook-로그인-구현&quot; id=&quot;markdown-toc-facebook-로그인-구현&quot;&gt;Facebook 로그인 구현&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#디버깅&quot; id=&quot;markdown-toc-디버깅&quot;&gt;디버깅&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#마무리&quot; id=&quot;markdown-toc-마무리&quot;&gt;마무리&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#참고자료&quot; id=&quot;markdown-toc-참고자료&quot;&gt;참고자료&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;들어가는-말&quot;&gt;들어가는 말&lt;/h2&gt;

&lt;p&gt;지난 시간에 다룬 &lt;a href=&quot;https://blog.totu.dev/2018/03/22/firebaseandunity-01/&quot;&gt;익명 로그인&lt;/a&gt;은 기본이다. 익명 로그인은 Apple의 앱스토어 검수 조건에도 해당한다.&lt;/p&gt;

&lt;p&gt;사용자가 선택할 수 있는 그 다음 선택지는 소셜 로그인이다. 비밀번호와 같은 자산이 Facebook이나 Google 등 대형 회사가 관리되니 안심되고 설령 게임을 지워도 다시 데이터를 복원을 기준을 제공해주기 때문이다.&lt;/p&gt;

&lt;p&gt;Firebase 인증은 Google, Play 게임(구글 플레이), Facebook, Twitter, Github 등의 로그인이 가능하다. 그 중 여기서는 페이스북 로그인을 다뤄보겠다.&lt;/p&gt;

&lt;h2 id=&quot;준비-과정&quot;&gt;준비 과정&lt;/h2&gt;
&lt;p&gt;Firebase 인증의 &lt;code&gt;로그인 방법&lt;/code&gt;에 Facebook을 등록해야한다. 그러기위해서는 Facebook에 앱을 생성해야한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://developers.facebook.com/apps/&quot;&gt;facebook for developers의 앱 대시보드&lt;/a&gt;에 접속 한 뒤 &lt;code&gt;새 앱 추가&lt;/code&gt; 버튼을 클릭한다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/fb_03_01_01.png&quot; alt=&quot;새 앱 추가&quot; width=&quot;10%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;표시할 이름과 연락처 이메일을 등록한다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/fb_03_01_02.png&quot; alt=&quot;새 앱 ID만들기 입력&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;페이스북 앱의 대시보드 중 &lt;code&gt;Facebook 로그인&lt;/code&gt;의 &lt;code&gt;설정&lt;/code&gt; 버튼을 클릭한다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/fb_03_01_03.png&quot; alt=&quot;Facebook 로그인 설정&quot; width=&quot;30%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이제 &lt;code&gt;빠른 시작&lt;/code&gt; 절차가 시작된다. 이를 무시하고 좌측 메뉴에서 &lt;code&gt;설정&lt;/code&gt; - &lt;code&gt;기본 설정&lt;/code&gt;을 클릭하여 &lt;code&gt;앱 ID&lt;/code&gt;와 &lt;code&gt;앱 시크릿 코드&lt;/code&gt;를 확인한다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/fb_03_01_05.png&quot; alt=&quot;설정 - 기본 설정&quot; width=&quot;30%&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/fb_03_01_06.png&quot; alt=&quot;앱 ID와 앱 시크릿 코드 확인&quot; width=&quot;30%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;하단의 &lt;code&gt;+ 플랫폼 추가&lt;/code&gt; 버튼을 클릭하고 iOS나 Android 등의 플랫폼을 선택한다(여기서는 iOS를 기준으로 설명한다). &lt;code&gt;번들 ID&lt;/code&gt;를 입력한다. 다 입력하면 하단의 &lt;code&gt;변경 내용 저장&lt;/code&gt;을 클릭한다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/fb_03_01_07.png&quot; alt=&quot;iOS 번들 ID 입력&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이제 아대시보드로 접속하여 &lt;code&gt;로그인 방법&lt;/code&gt;탭을 선택한 뒤 &lt;code&gt;Facebook&lt;/code&gt;을 클릭한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;사용 설정&lt;/code&gt;을 클릭하고 앞서 확인한 &lt;code&gt;앱 ID&lt;/code&gt;와 &lt;code&gt;앱 시크릿 코드&lt;/code&gt;를 입력한다. &lt;code&gt;OAuth 리디렉션 URI&lt;/code&gt;를 복사한다(복사 아이콘 클릭)하고 &lt;code&gt;저장&lt;/code&gt; 버튼을 클릭한다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/fb_03_01_08.png&quot; alt=&quot;앱 ID, 앱 시크릿 코드 입력&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;facebook for developers 대시보드로 돌아가서 복사한 &lt;code&gt;OAuth 리디렉션 URI&lt;/code&gt;를 &lt;code&gt;Facebook 로그인&lt;/code&gt; - &lt;code&gt;설정&lt;/code&gt;에서 &lt;code&gt;유효한 OAuth 리디렉션 URI&lt;/code&gt;에 붙여넣고 &lt;code&gt;변경 내용 저장&lt;/code&gt;을 클릭한다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/fb_03_01_09.png&quot; alt=&quot;좌측 메뉴의 Facebook 로그인 - 설정&quot; width=&quot;30%&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/fb_03_01_10.png&quot; alt=&quot;유효한 OAuth 리디렉션 URI 입력&quot; width=&quot;40%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;facebook-로그인&quot;&gt;Facebook 로그인&lt;/h2&gt;

&lt;p&gt;Facebook 로그인도 익명 로그인과 비슷한 절차로 진행된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자) Facebook 로그인 버튼 클릭&lt;/li&gt;
  &lt;li&gt;게임 클라이언트) Facebook SDK를 활용해서 로그인 화면 표시&lt;/li&gt;
  &lt;li&gt;사용자) 로그인 진행&lt;/li&gt;
  &lt;li&gt;Facebook) access token 반환&lt;/li&gt;
  &lt;li&gt;게임 클라이언트) access token을 Firebase 인증 SDK를 통해 등록&lt;/li&gt;
  &lt;li&gt;Firebase) 사용자 등록 과정 진행&lt;/li&gt;
  &lt;li&gt;게임 클라이언트) 고유한 사용자 ID를 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;프로그래밍-준비&quot;&gt;프로그래밍 준비&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://blog.totu.dev/2018/03/22/firebaseandunity-01/&quot;&gt;익명 로그인&lt;/a&gt;을 진행했다면 그 프로젝트를 이어서 사용해도 무방하다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;아래 프로젝트 파일을 다운받는다.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/totuworld/firebase_toturial/archive/auth_guest.zip&quot;&gt;샘플 프로젝트&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://developers.facebook.com/docs/unity&quot;&gt;Facebook SDK for Unity&lt;/a&gt;로 접속해서 Facebook Unity SDK를 다운로드한다(작성일 기준 v7.11.1).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Unity 2017.3를 실행한 뒤 샘플 프로젝트를 열고 &lt;a href=&quot;https://blog.totu.dev/2018/03/22/firebaseandunity-01/#프로젝트-설정&quot;&gt;익명 로그인&lt;/a&gt;의 &lt;code&gt;프로젝트 설정&lt;/code&gt; 부분을 참고하여 &lt;code&gt;GoogleService-Info.plist&lt;/code&gt; 파일을 생성하여 샘플 프로젝트에 추가한다. 다운로드한 Facebook Unity SDK도 추가한다.&lt;/p&gt;

    &lt;p&gt;Facebook Unity SDK를 추가하면 Firebase Auth SDK와 충돌하는 파일이 4개 있다. 프로젝트에 사용된 Firebase Unity SDK는 4.3이고 Facebook Unity SDK는 7.11.1이다. 충돌이나는 파일은 &lt;code&gt;PlayServicesResolver의&lt;/code&gt; 폴더에 있는 4개 파일인데 1.2.59 버전 파일을 모두 삭제한다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/fb_03_02_01.png&quot; alt=&quot;PlayServicesResolver 내 파일 삭제&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Android 빌드는 확인해보지 않아서 어떤 문제가 발생할지 모릅니다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Unity에서 &lt;code&gt;Facebook&lt;/code&gt; - &lt;code&gt;Edit Settings&lt;/code&gt; 메뉴 선택한 뒤 facebook for developers에서 확인한 &lt;code&gt;앱 ID&lt;/code&gt;를 입력한다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/fb_03_02_02.png&quot; alt=&quot;Facebook - Edit Settings 메뉴 선택&quot; width=&quot;20%&quot; /&gt;
  &lt;img src=&quot;/images/fb_03_02_03.png&quot; alt=&quot;Facebook 앱 ID 입력&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;facebook-로그인-구현&quot;&gt;Facebook 로그인 구현&lt;/h3&gt;

&lt;p&gt;Facebook 로그인은 2 단계로 진행된다. Facebook Unity SDK로 로그인을 진행하고, Facebook에서 반환한 access token으로 Firebase Auth SDK로 등록을 진행한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;gfb_auth_test.cs&lt;/code&gt; 스크립트를 열고 아래처럼 변경한다.
    &lt;ul&gt;
      &lt;li&gt;8번 줄: using으로 필요한 네임스페이스 형식 사용 허용(Facebook.Unity)&lt;/li&gt;
      &lt;li&gt;29~32번 줄(&lt;code&gt;Start&lt;/code&gt; 메서드 내): Facebook SDK를 초기화 추가&lt;/li&gt;
      &lt;li&gt;40~45번 줄: Firebase 인증 SDK로 signin이 된 상태인지 확인하는 프로퍼티 추가&lt;/li&gt;
      &lt;li&gt;90~184번 줄(페이스북 로그인 관련 메서드 region): 페이스북 로그인을 시도하고 firebase에 등록하는 메서드가 모여있다. 아래 흐름도를 살펴보고 코드를 보면 조금 더 이해하기 수월하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/fb_03_03_01.png&quot; alt=&quot;페이스북 흐름도&quot; /&gt;&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com//785a451847aebd36a548061a47cf261a.js?file=gfb_auth_test_for_fb.cs&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;gfb_auth_test의 &lt;code&gt;facebookLogin&lt;/code&gt; 메서드가 실행되어야 페이스북 로그인을 시도할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;Canvas - Button 게임 오브젝트의 Button 컴포넌트를 찾아서 복사한 뒤 적당히 위치 시키고 &lt;code&gt;Facebook Login&lt;/code&gt;으로 텍스트를 변&lt;/li&gt;
      &lt;li&gt;gfb_auth_test 스크립트의 &lt;code&gt;facebookLogin&lt;/code&gt;을 선택한다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;/images/fb_03_03_02.png&quot; alt=&quot;버큰 복사 후 텍스트 변경&quot; width=&quot;30%&quot; /&gt;
  &lt;img src=&quot;/images/fb_03_03_03.png&quot; alt=&quot;버튼 연결&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;디버깅&quot;&gt;디버깅&lt;/h3&gt;

&lt;p&gt;Firebase 인증 SDK로 Facebook 로그인을 시도하면 Unity Editor에서는 디버깅이 불가능하다. 빌드 후 앱 클라이언트에서 확인해야한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;iOS의 빌드의 경우 Facebook SDK 추가 후 빌드 시 Build Settting에서 Enable Bitcode를 No로 설정해야 linker 에러 없이 진행된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/fb_03_04_01.png&quot; alt=&quot;등록 확인&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Facebook 로그인 후 Firebase에 등록을 마치면 위 그림처럼 나타난다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/totuworld/firebase_toturial/archive/auth_facebook.zip&quot;&gt;완료된소스코드&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;마무리&quot;&gt;마무리&lt;/h2&gt;

&lt;p&gt;간단히 끝날 내용이었는데 linker 에러와 Firebase 내의 Facebook 앱 ID를 잘못 입력해서 많은 빌드 실패가 있었다. 꼭 설정은 2번 3번 확인하길 바란다.&lt;/p&gt;

&lt;p&gt;그리고 이런 다양한 문제를 해결하고 있는 클라이언트 프로그래머 여러분 대단하십니다👍👍👍.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://firebase.google.com/docs/auth/unity/facebook-login&quot;&gt;Authenticate Using Facebook Login and Unity&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://firebase.google.com/docs/auth/unity/account-linking&quot;&gt;Link Multiple Auth Providers to an Account in Unity&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.facebook.com/docs/unity/examples#login&quot;&gt;Facebook SDK for Unity - Examples&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/facebook/facebook-sdk-for-unity/issues/135&quot;&gt;Facebook SDK for Unity isssue 135&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
            <pubDate>Thu, 22 Mar 2018 09:00:00 +0900</pubDate>
            <link />https://blog.totu.dev/2018/03/22/firebaseandunity-02/&lt;/link&gt;
            <guid isPermaLink="true">https://blog.totu.dev/2018/03/22/firebaseandunity-02/</guid>
            
            
            <category>nodejs</category>
            
            <category>firebase</category>
            
            <category>unity</category>
            
        </item>
      
    
      
        <item>
            <title>3분 게임 서버(Firebase) - Auth 익명 로그인</title>
            <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#들어가는-말&quot; id=&quot;markdown-toc-들어가는-말&quot;&gt;들어가는 말&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#고백&quot; id=&quot;markdown-toc-고백&quot;&gt;고백&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#firebase의-약팔이-새로운-기능&quot; id=&quot;markdown-toc-firebase의-약팔이-새로운-기능&quot;&gt;Firebase의 &lt;del&gt;약팔이&lt;/del&gt; 새로운 기능&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#사용자-로그인-흐름&quot; id=&quot;markdown-toc-사용자-로그인-흐름&quot;&gt;사용자 로그인 흐름&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#준비-과정&quot; id=&quot;markdown-toc-준비-과정&quot;&gt;준비 과정&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#프로젝트-추가&quot; id=&quot;markdown-toc-프로젝트-추가&quot;&gt;프로젝트 추가&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#프로젝트-설정&quot; id=&quot;markdown-toc-프로젝트-설정&quot;&gt;프로젝트 설정&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#익명-로그인&quot; id=&quot;markdown-toc-익명-로그인&quot;&gt;익명 로그인&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#프로그래밍-준비&quot; id=&quot;markdown-toc-프로그래밍-준비&quot;&gt;프로그래밍 준비&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#익명-로그인-구현&quot; id=&quot;markdown-toc-익명-로그인-구현&quot;&gt;익명 로그인 구현&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#디버깅&quot; id=&quot;markdown-toc-디버깅&quot;&gt;디버깅&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#마무리&quot; id=&quot;markdown-toc-마무리&quot;&gt;마무리&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;들어가는-말&quot;&gt;들어가는 말&lt;/h2&gt;

&lt;h3 id=&quot;고백&quot;&gt;고백&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.totu.dev/2016/12/21/azureandunity-01/&quot;&gt;이세계에 진입한 서버 개발&lt;/a&gt;을 시작하고 1년이 지났다. 그 동안 이직을 했고 바쁜 시간을 보냈다는 핑계로 업데이트 없는 9개월을 보냈다.&lt;/p&gt;

&lt;p&gt;놀기만 했으면 좋으련만 6월부터 &lt;code&gt;이세계에 진입한 서버 개발&lt;/code&gt;을 책으로 출판할 생각으로 작업중이었는데 최근 절필했다. 2가지 이유가 있다. 하나는 오래된 코드라서 봐줄 수 없었다(이건 내 실력이…). 다른 하나는 게임 클라이언트 프로그래머만 있는 소규모 게임 개발팀에서 node.js와 관계형 데이터베이스를 공부해서 게임용 웹 서버를 만들 수 있을까하는 의문이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;게임 개발할 시간도 없는데 서버는 젠장!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Wendy를 활용하는 게임 클라이언트 프로그래머가 인프라 공부에 시간 보낼까봐 PaaS(Platform as a Service)를 사용하도록 유도했지만 충분한 대답이 아니었다. 이보다 더 낮은 진입이 가능해야 순수 클라이언트 프로그래머가 공부할 수 있을 듯 했다. 그렇다면 좋은 서비스는 Parse나 Firebase같은 BaaS(Backend as a Service)다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Facebook이 인수하여 서비스하던 Parse는 서비스가 종료되었다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;firebase의-약팔이-새로운-기능&quot;&gt;Firebase의 &lt;del&gt;약팔이&lt;/del&gt; 새로운 기능&lt;/h3&gt;

&lt;p&gt;과거의 Firebase는 모바일 게임용 백엔드로 활용하기에 문제가 있었다. 게임 클라이언트에 Firebase SDK를 활용해 비지니스 로직을 넣게된다. 운영중에 비지니스 로직에 문제가 발생하면 모바일 게임은 플랫폼 심사 시간이 있어 빠른 대처가 어렵다. 출시 후 운영중에 대처가 늦으면 사용자 감소와 함께 매출이 감소한다. 이런 부담은 QA로 해소될 수 있으나 소규모 게임 제작팀은 비용때문에 불가능하다.&lt;/p&gt;

&lt;p&gt;2017년 3월 Firebase에 node.js 환경으로 프로그래밍이 가능한 &lt;code&gt;Cloud Functions&lt;/code&gt;이 추가되었다. 이 기능을 활용하면 비지니스 로직을 게임 클라이언트 외부로 옮길 수 있다. 또 Firebase에 &lt;code&gt;Realtime Database&lt;/code&gt;외에도 &lt;code&gt;Cloud Firestore&lt;/code&gt;란 데이터베이스가 추가되었다. 이제 거대한 파일 하나에 모든 데이터를 넣지 않아도 된다. 단, 아직까지 Firebase Unity SDK에서는 사용할 수 없다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;MS에서도 &lt;a href=&quot;http://Playfab.com&quot;&gt;Playfab&lt;/a&gt;을 인수하여 Google의 Firebase같은 서비스를 제공할 예정이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;새롭게 연재하는 글에서는 Firebase를 이용해서 게임 서버를 사용하도록 권장한다. 특히 클라이언트 프로그래머가 보유한 팀이라면 더더욱 이 방법을 추천한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;처음부터 c++로 서버 프로그래밍하는 책 사지 마시라. 어느정도 필요가 차올랐을 때 아주 간단한 것부터 시작하길 권한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;사용자-로그인-흐름&quot;&gt;사용자 로그인 흐름&lt;/h2&gt;
&lt;p&gt;서론이 길었다. 이번에 진행할 것은 익명 로그인이다. 먼저 사용자가 게임을 시작했을 때 어떤 단계를 걸치는지 상상해보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;타이틀 화면
    &lt;ul&gt;
      &lt;li&gt;게스트/페북 로그인 클릭(1회면 진행됨)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;/images/fb_02_01_01n.png&quot; alt=&quot;타이틀 화면&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;로그인 절차&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/fb_02_01_02n.png&quot; alt=&quot;로그인&quot; width=&quot;30%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;게임 플레이&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/fb_02_01_03n.png&quot; alt=&quot;게임 플레이&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 과정을 거치는 이유는 제작자 혹은 운영자가 통제하는 시스템에 등록된 사용자인지 확인하기 위해서이다. 그럼 가장 간편한 로그인 방식인 익명 로그인 - 혹은 게스트 로그인 - 을 Firebase 인증(Authentication)을 활용해서 제작해보자.&lt;/p&gt;

&lt;p&gt;가장 간편한 로그인 방식인 익명 로그인을 알아보자.&lt;/p&gt;

&lt;h2 id=&quot;준비-과정&quot;&gt;준비 과정&lt;/h2&gt;
&lt;p&gt;Unity 클라이언트에서 Firebase 인증을 활용해서 익명 로그인을 구현하려면 몇가지 선행 과정이 필요하다.&lt;/p&gt;

&lt;h3 id=&quot;프로젝트-추가&quot;&gt;프로젝트 추가&lt;/h3&gt;

&lt;p&gt;Firebase 프로젝트 추가에 앞서 Firebase를 사용하려면 google 계정이 필요하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;google 계정으로 로그인 한다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://console.firebase.google.com/&quot;&gt;Firebase console&lt;/a&gt;로 이동한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;프로젝트 추가&lt;/code&gt;를 클릭한다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/fb_01_01.png&quot; alt=&quot;프로젝트 추가&quot; width=&quot;30%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;프로젝트 이름&lt;/code&gt;을 입력하고 &lt;code&gt;국가/지역&lt;/code&gt;을 선택한 뒤 &lt;code&gt;프로젝트 만들기&lt;/code&gt;를 클릭한다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/fb_01_02.png&quot; alt=&quot;프로젝트 추가&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;프로젝트-설정&quot;&gt;프로젝트 설정&lt;/h3&gt;
&lt;p&gt;Firebase를 클라이언트(Android, iOS, Web)에서 사용하려면 설정을 추가하면 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;여기서는 iOS로 설명하지만 Android라고 크게 다를건 없다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;Project Overview&lt;/code&gt; 메뉴 옆에 기어 모양 설정 버튼을 클릭하고 프로젝트 설정을 클릭한다.
  &lt;img src=&quot;/images/fb_01_03_1.png&quot; alt=&quot;프로젝트 설정&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;일반 탭에서 하단의 &lt;code&gt;iOS 앱에 Firebase 추가&lt;/code&gt; 클릭한다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/fb_01_03_2.png&quot; alt=&quot;iOS 추가&quot; width=&quot;20%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;iOS 번들 ID&lt;/code&gt;를 입력하고 나머지 선택사항도 필요에 따라 입력한다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/fb_01_03_3.png&quot; alt=&quot;입력&quot; width=&quot;30%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;GoogleService-Info.plist&lt;/code&gt; 파일을 다운받고 계속 버튼을 눌러 등록 과정을 마친다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;익명-로그인&quot;&gt;익명 로그인&lt;/h2&gt;
&lt;p&gt;익명 로그인이 요구하는 사항은 간단하다. 여러가지 정보를 취합해서 게임 내에서 사용자를 고유하게 인식할 수 있으면 된다. 다음 절차로 진행된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자) 익명 로그인 버튼 클릭&lt;/li&gt;
  &lt;li&gt;게임 클라이언트) Firebase 인증 SDK에 익명 로그인 요청&lt;/li&gt;
  &lt;li&gt;Firebase) 여러가지 정보 확인 후 고유한 사용자 ID 반환&lt;/li&gt;
  &lt;li&gt;게임 클라이언트) 고유한 사용자 ID 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;프로그래밍-준비&quot;&gt;프로그래밍 준비&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;먼저 간단한 UI를 추가해놓은 아래 Unity Project를 다운 받는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/totuworld/firebase_toturial/archive/base.zip&quot;&gt;샘플 프로젝트&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Firebase SDK를 다운받아서 Firebase Auth SDK를 설치한다. 그리고 앞서 Firebase 프로젝트에서 다운받은 &lt;code&gt;GoogleService-Info.plist&lt;/code&gt;나 &lt;code&gt;google-services.json&lt;/code&gt;을 추가한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Firebase의 Authentication 메뉴에서 &lt;code&gt;로그인 방법&lt;/code&gt; 탭을 클릭한 뒤 &lt;code&gt;익명&lt;/code&gt; 사용 설정한다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/fb_02_02_01.png&quot; alt=&quot;Authentication&quot; width=&quot;30%&quot; /&gt;
  &lt;img src=&quot;/images/fb_02_02_02.png&quot; alt=&quot;익명 사용 설정&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;익명-로그인-구현&quot;&gt;익명 로그인 구현&lt;/h3&gt;
&lt;p&gt;Firebase 인증을 활용할 때 초기화 후 익명 로그인 요청을 해야한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;unity 프로젝트의 프로젝트 탭에서 scripts 폴더를 만들고 &lt;code&gt;gfb_auth_test&lt;/code&gt;란 이름의 새로운 c# script 파일을 생성한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;이름은 달라도 무방하다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;추가한 스크립트를 편집할 수 있게 더블 클릭한 후 아래 코드를 복사하여 붙여넣는다.
    &lt;ul&gt;
      &lt;li&gt;4~7번: using으로 필요한 네임스페이스 형식 사용 허용&lt;/li&gt;
      &lt;li&gt;11~18번: 필요한 필드 추가&lt;/li&gt;
      &lt;li&gt;23~49번: &lt;code&gt;auth&lt;/code&gt;필드를 추가하고 상태변화 시 로그가 남도록 AuthStateChanged 메서드 연결.&lt;/li&gt;
      &lt;li&gt;52~69번: 익명 로그인을 요청하는 메서드&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;script src=&quot;https://gist.github.com//785a451847aebd36a548061a47cf261a.js?file=gfb_auth_test.cs&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;unity 프로젝트로 돌아가서 &lt;code&gt;test&lt;/code&gt;씬의 &lt;code&gt;Main Camera&lt;/code&gt; 게임 오브젝트에 &lt;code&gt;gfb_auth_test&lt;/code&gt; 스크립트를 추가한다. Canvas - Scroll View - ViewPort - Content 게임 오브젝트를 &lt;code&gt;gfb_auth_test&lt;/code&gt;의 Txt Print에 연결한다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/fb_02_03.png&quot; alt=&quot;게임 오브젝트 연결&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;guest login 버튼을 클릭했을 때 gfb_auth_test의 &lt;code&gt;anoymousLogin&lt;/code&gt; 메서드가 실행되어야 익명 로그인을 시도할 수 있다.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;Canvas - Button 게임 오브젝트의 Button 컴포넌트를 찾는다.&lt;/li&gt;
      &lt;li&gt;On Click의 + 버튼을 클릭한 뒤 Main Camera 게임 오브젝트를 연결한다.&lt;/li&gt;
      &lt;li&gt;gfb_auth_test 스크립트의 anoymousLogin을 선택한다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;/images/fb_02_04.png&quot; alt=&quot;버튼 연결&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;디버깅&quot;&gt;디버깅&lt;/h3&gt;

&lt;p&gt;unity 프로젝트에서 &lt;code&gt;play&lt;/code&gt; 버튼을 클릭하여 작동 시킨 뒤 화면 중앙에 나타나는 &lt;code&gt;guest login&lt;/code&gt; 버튼을 클릭한다. 아래 스크롤뷰에 즉시 &lt;code&gt;Sign in...&lt;/code&gt; 메시지가 출력된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;모바일 앱으로 빌드해서 확인하려면 앞서 다운받은 &lt;code&gt;GoogleService-Info.plist&lt;/code&gt;나 &lt;code&gt;google-services.json&lt;/code&gt; 파일을 반드시 프로젝트에 추가해야한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;모바일 앱으로 빌드해서 해당 과정을 진행하면 Firebase console에 아래처럼 익명 사용자가 등록되는 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/fb_02_05.png&quot; alt=&quot;익명 사용자 확인&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;마무리&quot;&gt;마무리&lt;/h2&gt;

&lt;p&gt;Firebase 인증을 활용하여 익명 로그인을 만들어봤다. 이를 바탕으로 다음에는 소셜 로그인 기능을 추가해보자.&lt;/p&gt;
</description>
            <pubDate>Thu, 22 Mar 2018 09:00:00 +0900</pubDate>
            <link />https://blog.totu.dev/2018/03/22/firebaseandunity-01/&lt;/link&gt;
            <guid isPermaLink="true">https://blog.totu.dev/2018/03/22/firebaseandunity-01/</guid>
            
            
            <category>nodejs</category>
            
            <category>firebase</category>
            
            <category>unity</category>
            
        </item>
      
    
  </channel>
</rss>
